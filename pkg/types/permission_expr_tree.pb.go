// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sourcenetwork/acp_core/permission_expr_tree.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Combinator expresses a set combinator which
// merges the result of two fetch operatiosn
type Combinator int32

const (
	Combinator_COMB_UNKNOWN Combinator = 0
	Combinator_UNION        Combinator = 1
	Combinator_DIFFERENCE   Combinator = 2
	Combinator_INTERSECTION Combinator = 3
)

var Combinator_name = map[int32]string{
	0: "COMB_UNKNOWN",
	1: "UNION",
	2: "DIFFERENCE",
	3: "INTERSECTION",
}

var Combinator_value = map[string]int32{
	"COMB_UNKNOWN": 0,
	"UNION":        1,
	"DIFFERENCE":   2,
	"INTERSECTION": 3,
}

func (x Combinator) String() string {
	return proto.EnumName(Combinator_name, int32(x))
}

func (Combinator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{0}
}

// PermissionExpr models a permission fetch tree,
// which controls how a permission is evaluated
type PermissionFetchTree struct {
	// Types that are valid to be assigned to Term:
	//	*PermissionFetchTree_Operation
	//	*PermissionFetchTree_CombNode
	Term isPermissionFetchTree_Term `protobuf_oneof:"term"`
}

func (m *PermissionFetchTree) Reset()         { *m = PermissionFetchTree{} }
func (m *PermissionFetchTree) String() string { return proto.CompactTextString(m) }
func (*PermissionFetchTree) ProtoMessage()    {}
func (*PermissionFetchTree) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{0}
}
func (m *PermissionFetchTree) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PermissionFetchTree) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PermissionFetchTree.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PermissionFetchTree) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PermissionFetchTree.Merge(m, src)
}
func (m *PermissionFetchTree) XXX_Size() int {
	return m.Size()
}
func (m *PermissionFetchTree) XXX_DiscardUnknown() {
	xxx_messageInfo_PermissionFetchTree.DiscardUnknown(m)
}

var xxx_messageInfo_PermissionFetchTree proto.InternalMessageInfo

type isPermissionFetchTree_Term interface {
	isPermissionFetchTree_Term()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PermissionFetchTree_Operation struct {
	Operation *FetchOperation `protobuf:"bytes,1,opt,name=operation,proto3,oneof" json:"operation,omitempty"`
}
type PermissionFetchTree_CombNode struct {
	CombNode *CombinationNode `protobuf:"bytes,2,opt,name=comb_node,json=combNode,proto3,oneof" json:"comb_node,omitempty"`
}

func (*PermissionFetchTree_Operation) isPermissionFetchTree_Term() {}
func (*PermissionFetchTree_CombNode) isPermissionFetchTree_Term()  {}

func (m *PermissionFetchTree) GetTerm() isPermissionFetchTree_Term {
	if m != nil {
		return m.Term
	}
	return nil
}

func (m *PermissionFetchTree) GetOperation() *FetchOperation {
	if x, ok := m.GetTerm().(*PermissionFetchTree_Operation); ok {
		return x.Operation
	}
	return nil
}

func (m *PermissionFetchTree) GetCombNode() *CombinationNode {
	if x, ok := m.GetTerm().(*PermissionFetchTree_CombNode); ok {
		return x.CombNode
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PermissionFetchTree) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PermissionFetchTree_Operation)(nil),
		(*PermissionFetchTree_CombNode)(nil),
	}
}

// CombinationNode models a term which has a left and right expr alongside a combinator
type CombinationNode struct {
	Left       *PermissionFetchTree `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Combinator Combinator           `protobuf:"varint,2,opt,name=combinator,proto3,enum=sourcenetwork.acp_core.Combinator" json:"combinator,omitempty"`
	Right      *PermissionFetchTree `protobuf:"bytes,3,opt,name=right,proto3" json:"right,omitempty"`
}

func (m *CombinationNode) Reset()         { *m = CombinationNode{} }
func (m *CombinationNode) String() string { return proto.CompactTextString(m) }
func (*CombinationNode) ProtoMessage()    {}
func (*CombinationNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{1}
}
func (m *CombinationNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombinationNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombinationNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombinationNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombinationNode.Merge(m, src)
}
func (m *CombinationNode) XXX_Size() int {
	return m.Size()
}
func (m *CombinationNode) XXX_DiscardUnknown() {
	xxx_messageInfo_CombinationNode.DiscardUnknown(m)
}

var xxx_messageInfo_CombinationNode proto.InternalMessageInfo

func (m *CombinationNode) GetLeft() *PermissionFetchTree {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *CombinationNode) GetCombinator() Combinator {
	if m != nil {
		return m.Combinator
	}
	return Combinator_COMB_UNKNOWN
}

func (m *CombinationNode) GetRight() *PermissionFetchTree {
	if m != nil {
		return m.Right
	}
	return nil
}

// FetchOperation models a terminal in the permission expr tree, meaning a single fetch operator
type FetchOperation struct {
	// Types that are valid to be assigned to Operation:
	//	*FetchOperation_Cu
	//	*FetchOperation_This
	//	*FetchOperation_Ttu
	Operation isFetchOperation_Operation `protobuf_oneof:"operation"`
}

func (m *FetchOperation) Reset()         { *m = FetchOperation{} }
func (m *FetchOperation) String() string { return proto.CompactTextString(m) }
func (*FetchOperation) ProtoMessage()    {}
func (*FetchOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{2}
}
func (m *FetchOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchOperation.Merge(m, src)
}
func (m *FetchOperation) XXX_Size() int {
	return m.Size()
}
func (m *FetchOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchOperation.DiscardUnknown(m)
}

var xxx_messageInfo_FetchOperation proto.InternalMessageInfo

type isFetchOperation_Operation interface {
	isFetchOperation_Operation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FetchOperation_Cu struct {
	Cu *ComputedUsersetNode `protobuf:"bytes,1,opt,name=cu,proto3,oneof" json:"cu,omitempty"`
}
type FetchOperation_This struct {
	This *ThisNode `protobuf:"bytes,2,opt,name=this,proto3,oneof" json:"this,omitempty"`
}
type FetchOperation_Ttu struct {
	Ttu *TupleToUsersetNode `protobuf:"bytes,3,opt,name=ttu,proto3,oneof" json:"ttu,omitempty"`
}

func (*FetchOperation_Cu) isFetchOperation_Operation()   {}
func (*FetchOperation_This) isFetchOperation_Operation() {}
func (*FetchOperation_Ttu) isFetchOperation_Operation()  {}

func (m *FetchOperation) GetOperation() isFetchOperation_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *FetchOperation) GetCu() *ComputedUsersetNode {
	if x, ok := m.GetOperation().(*FetchOperation_Cu); ok {
		return x.Cu
	}
	return nil
}

func (m *FetchOperation) GetThis() *ThisNode {
	if x, ok := m.GetOperation().(*FetchOperation_This); ok {
		return x.This
	}
	return nil
}

func (m *FetchOperation) GetTtu() *TupleToUsersetNode {
	if x, ok := m.GetOperation().(*FetchOperation_Ttu); ok {
		return x.Ttu
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FetchOperation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FetchOperation_Cu)(nil),
		(*FetchOperation_This)(nil),
		(*FetchOperation_Ttu)(nil),
	}
}

// ComputedUsersetNode models a computed userset operation
type ComputedUsersetNode struct {
	Relation string `protobuf:"bytes,1,opt,name=relation,proto3" json:"relation,omitempty"`
}

func (m *ComputedUsersetNode) Reset()         { *m = ComputedUsersetNode{} }
func (m *ComputedUsersetNode) String() string { return proto.CompactTextString(m) }
func (*ComputedUsersetNode) ProtoMessage()    {}
func (*ComputedUsersetNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{3}
}
func (m *ComputedUsersetNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputedUsersetNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComputedUsersetNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComputedUsersetNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputedUsersetNode.Merge(m, src)
}
func (m *ComputedUsersetNode) XXX_Size() int {
	return m.Size()
}
func (m *ComputedUsersetNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputedUsersetNode.DiscardUnknown(m)
}

var xxx_messageInfo_ComputedUsersetNode proto.InternalMessageInfo

func (m *ComputedUsersetNode) GetRelation() string {
	if m != nil {
		return m.Relation
	}
	return ""
}

// ThisNode models a fetch this operation
type ThisNode struct {
}

func (m *ThisNode) Reset()         { *m = ThisNode{} }
func (m *ThisNode) String() string { return proto.CompactTextString(m) }
func (*ThisNode) ProtoMessage()    {}
func (*ThisNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{4}
}
func (m *ThisNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThisNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThisNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThisNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThisNode.Merge(m, src)
}
func (m *ThisNode) XXX_Size() int {
	return m.Size()
}
func (m *ThisNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ThisNode.DiscardUnknown(m)
}

var xxx_messageInfo_ThisNode proto.InternalMessageInfo

// TupleToUsersetNode models a Tuple to Userset operation
type TupleToUsersetNode struct {
	Resource string `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	Relation string `protobuf:"bytes,2,opt,name=relation,proto3" json:"relation,omitempty"`
}

func (m *TupleToUsersetNode) Reset()         { *m = TupleToUsersetNode{} }
func (m *TupleToUsersetNode) String() string { return proto.CompactTextString(m) }
func (*TupleToUsersetNode) ProtoMessage()    {}
func (*TupleToUsersetNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeadfa5d5fa58c6a, []int{5}
}
func (m *TupleToUsersetNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TupleToUsersetNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TupleToUsersetNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TupleToUsersetNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TupleToUsersetNode.Merge(m, src)
}
func (m *TupleToUsersetNode) XXX_Size() int {
	return m.Size()
}
func (m *TupleToUsersetNode) XXX_DiscardUnknown() {
	xxx_messageInfo_TupleToUsersetNode.DiscardUnknown(m)
}

var xxx_messageInfo_TupleToUsersetNode proto.InternalMessageInfo

func (m *TupleToUsersetNode) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *TupleToUsersetNode) GetRelation() string {
	if m != nil {
		return m.Relation
	}
	return ""
}

func init() {
	proto.RegisterEnum("sourcenetwork.acp_core.Combinator", Combinator_name, Combinator_value)
	proto.RegisterType((*PermissionFetchTree)(nil), "sourcenetwork.acp_core.PermissionFetchTree")
	proto.RegisterType((*CombinationNode)(nil), "sourcenetwork.acp_core.CombinationNode")
	proto.RegisterType((*FetchOperation)(nil), "sourcenetwork.acp_core.FetchOperation")
	proto.RegisterType((*ComputedUsersetNode)(nil), "sourcenetwork.acp_core.ComputedUsersetNode")
	proto.RegisterType((*ThisNode)(nil), "sourcenetwork.acp_core.ThisNode")
	proto.RegisterType((*TupleToUsersetNode)(nil), "sourcenetwork.acp_core.TupleToUsersetNode")
}

func init() {
	proto.RegisterFile("sourcenetwork/acp_core/permission_expr_tree.proto", fileDescriptor_eeadfa5d5fa58c6a)
}

var fileDescriptor_eeadfa5d5fa58c6a = []byte{
	// 474 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xc1, 0x8a, 0xd3, 0x40,
	0x18, 0xc7, 0x33, 0x69, 0x77, 0x69, 0xbf, 0x95, 0x5a, 0x66, 0x41, 0x8a, 0x87, 0xb0, 0xe4, 0xa0,
	0xb2, 0x0b, 0x29, 0xbb, 0x82, 0x37, 0x15, 0x13, 0x53, 0xb6, 0xac, 0xa6, 0x12, 0x53, 0x04, 0x2f,
	0x61, 0x3b, 0xfd, 0x6c, 0xc2, 0x36, 0x99, 0x30, 0x99, 0xa0, 0xbe, 0x85, 0x2f, 0xe2, 0x7b, 0x78,
	0xdc, 0x83, 0x07, 0xbd, 0x49, 0xfb, 0x22, 0x92, 0x34, 0xdd, 0x6e, 0xb4, 0xa1, 0xec, 0x2d, 0x03,
	0xff, 0xdf, 0x6f, 0xfe, 0xf3, 0x65, 0x06, 0x4e, 0x53, 0x9e, 0x09, 0x86, 0x31, 0xca, 0xcf, 0x5c,
	0x5c, 0xf5, 0x2f, 0x59, 0xe2, 0x33, 0x2e, 0xb0, 0x9f, 0xa0, 0x88, 0xc2, 0x34, 0x0d, 0x79, 0xec,
	0xe3, 0x97, 0x44, 0xf8, 0x52, 0x20, 0x1a, 0x89, 0xe0, 0x92, 0xd3, 0x07, 0x15, 0xc4, 0x58, 0x23,
	0xfa, 0x77, 0x02, 0x87, 0xef, 0x6e, 0xb0, 0x01, 0x4a, 0x16, 0x78, 0x02, 0x91, 0x0e, 0xa0, 0xcd,
	0x13, 0x14, 0x97, 0x32, 0xe4, 0x71, 0x8f, 0x1c, 0x91, 0x27, 0x07, 0x67, 0x8f, 0x8c, 0xed, 0x0e,
	0xa3, 0xa0, 0x46, 0xeb, 0xf4, 0xb9, 0xe2, 0x6e, 0xd0, 0xdc, 0xc3, 0x78, 0x34, 0xf1, 0x63, 0x3e,
	0xc5, 0x9e, 0x5a, 0x78, 0x1e, 0xd7, 0x79, 0x2c, 0x1e, 0x4d, 0xc2, 0xb8, 0xe0, 0x1c, 0x3e, 0xc5,
	0x73, 0xc5, 0x6d, 0xe5, 0x6c, 0xfe, 0x6d, 0xee, 0x43, 0x53, 0xa2, 0x88, 0xf4, 0xdf, 0x04, 0xee,
	0xff, 0x93, 0xa3, 0x2f, 0xa1, 0x39, 0xc7, 0x4f, 0xb2, 0xac, 0x79, 0x52, 0xa7, 0xdf, 0x72, 0x4c,
	0xb7, 0x00, 0xa9, 0x09, 0xc0, 0x4a, 0x27, 0x17, 0x45, 0xcb, 0xce, 0x99, 0xbe, 0xab, 0x25, 0x17,
	0xee, 0x2d, 0x8a, 0xbe, 0x82, 0x3d, 0x11, 0xce, 0x02, 0xd9, 0x6b, 0xdc, 0xbd, 0xc5, 0x8a, 0xd4,
	0x7f, 0x12, 0xe8, 0x54, 0x67, 0x49, 0x9f, 0x83, 0xca, 0xb2, 0x5d, 0x07, 0xb3, 0x78, 0x94, 0x64,
	0x12, 0xa7, 0xe3, 0x14, 0x45, 0x8a, 0xb2, 0x9c, 0x9d, 0xca, 0x32, 0xfa, 0x0c, 0x9a, 0x32, 0x08,
	0xd3, 0x72, 0xf0, 0x47, 0x75, 0x02, 0x2f, 0x08, 0xd3, 0x92, 0x2a, 0xf2, 0xf4, 0x05, 0x34, 0xa4,
	0xcc, 0xca, 0xa3, 0x1c, 0xd7, 0x62, 0x59, 0x32, 0x47, 0x8f, 0x57, 0xb7, 0xcd, 0x41, 0xf3, 0xe0,
	0xd6, 0xed, 0xd1, 0x4f, 0xe1, 0x70, 0x4b, 0x43, 0xfa, 0x10, 0x5a, 0x02, 0xe7, 0x9b, 0x0b, 0xd6,
	0x76, 0x6f, 0xd6, 0x3a, 0x40, 0x6b, 0xdd, 0x49, 0x7f, 0x03, 0xf4, 0xff, 0x8d, 0x56, 0xf4, 0xaa,
	0xd7, 0x86, 0x5e, 0xad, 0x2b, 0x66, 0xb5, 0x6a, 0x3e, 0xbe, 0x00, 0xd8, 0xfc, 0x40, 0xda, 0x85,
	0x7b, 0xd6, 0xe8, 0xad, 0xe9, 0x8f, 0x9d, 0x0b, 0x67, 0xf4, 0xc1, 0xe9, 0x2a, 0xb4, 0x0d, 0x7b,
	0x63, 0x67, 0x38, 0x72, 0xba, 0x84, 0x76, 0x00, 0x5e, 0x0f, 0x07, 0x03, 0xdb, 0xb5, 0x1d, 0xcb,
	0xee, 0xaa, 0x79, 0x78, 0xe8, 0x78, 0xb6, 0xfb, 0xde, 0xb6, 0xbc, 0x3c, 0xd1, 0x30, 0xed, 0x1f,
	0x0b, 0x8d, 0x5c, 0x2f, 0x34, 0xf2, 0x67, 0xa1, 0x91, 0x6f, 0x4b, 0x4d, 0xb9, 0x5e, 0x6a, 0xca,
	0xaf, 0xa5, 0xa6, 0x7c, 0x3c, 0x99, 0x85, 0x32, 0xc8, 0x26, 0x06, 0xe3, 0x51, 0xbf, 0xee, 0xb1,
	0x5e, 0xcd, 0xfa, 0xf2, 0x6b, 0x82, 0xe9, 0x64, 0xbf, 0x78, 0xa2, 0x4f, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0xa9, 0xa7, 0xdc, 0x70, 0xd7, 0x03, 0x00, 0x00,
}

func (m *PermissionFetchTree) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PermissionFetchTree) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionFetchTree) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Term != nil {
		{
			size := m.Term.Size()
			i -= size
			if _, err := m.Term.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PermissionFetchTree_Operation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionFetchTree_Operation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Operation != nil {
		{
			size, err := m.Operation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PermissionFetchTree_CombNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PermissionFetchTree_CombNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CombNode != nil {
		{
			size, err := m.CombNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CombinationNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombinationNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CombinationNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Combinator != 0 {
		i = encodeVarintPermissionExprTree(dAtA, i, uint64(m.Combinator))
		i--
		dAtA[i] = 0x10
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operation != nil {
		{
			size := m.Operation.Size()
			i -= size
			if _, err := m.Operation.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchOperation_Cu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchOperation_Cu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cu != nil {
		{
			size, err := m.Cu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FetchOperation_This) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchOperation_This) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.This != nil {
		{
			size, err := m.This.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FetchOperation_Ttu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchOperation_Ttu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ttu != nil {
		{
			size, err := m.Ttu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPermissionExprTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ComputedUsersetNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputedUsersetNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputedUsersetNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relation) > 0 {
		i -= len(m.Relation)
		copy(dAtA[i:], m.Relation)
		i = encodeVarintPermissionExprTree(dAtA, i, uint64(len(m.Relation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThisNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThisNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThisNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TupleToUsersetNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TupleToUsersetNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TupleToUsersetNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relation) > 0 {
		i -= len(m.Relation)
		copy(dAtA[i:], m.Relation)
		i = encodeVarintPermissionExprTree(dAtA, i, uint64(len(m.Relation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintPermissionExprTree(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPermissionExprTree(dAtA []byte, offset int, v uint64) int {
	offset -= sovPermissionExprTree(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PermissionFetchTree) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != nil {
		n += m.Term.Size()
	}
	return n
}

func (m *PermissionFetchTree_Operation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		l = m.Operation.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}
func (m *PermissionFetchTree_CombNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CombNode != nil {
		l = m.CombNode.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}
func (m *CombinationNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	if m.Combinator != 0 {
		n += 1 + sovPermissionExprTree(uint64(m.Combinator))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}

func (m *FetchOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != nil {
		n += m.Operation.Size()
	}
	return n
}

func (m *FetchOperation_Cu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cu != nil {
		l = m.Cu.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}
func (m *FetchOperation_This) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.This != nil {
		l = m.This.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}
func (m *FetchOperation_Ttu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ttu != nil {
		l = m.Ttu.Size()
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}
func (m *ComputedUsersetNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Relation)
	if l > 0 {
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}

func (m *ThisNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TupleToUsersetNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	l = len(m.Relation)
	if l > 0 {
		n += 1 + l + sovPermissionExprTree(uint64(l))
	}
	return n
}

func sovPermissionExprTree(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPermissionExprTree(x uint64) (n int) {
	return sovPermissionExprTree(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PermissionFetchTree) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PermissionFetchTree: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PermissionFetchTree: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FetchOperation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Term = &PermissionFetchTree_Operation{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CombinationNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Term = &PermissionFetchTree_CombNode{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissionExprTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinationNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombinationNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombinationNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &PermissionFetchTree{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combinator", wireType)
			}
			m.Combinator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Combinator |= Combinator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &PermissionFetchTree{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissionExprTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ComputedUsersetNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &FetchOperation_Cu{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field This", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ThisNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &FetchOperation_This{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TupleToUsersetNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Operation = &FetchOperation_Ttu{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissionExprTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputedUsersetNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputedUsersetNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputedUsersetNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissionExprTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThisNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThisNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThisNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPermissionExprTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TupleToUsersetNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TupleToUsersetNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TupleToUsersetNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPermissionExprTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPermissionExprTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPermissionExprTree(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPermissionExprTree
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPermissionExprTree
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPermissionExprTree
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPermissionExprTree
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPermissionExprTree
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPermissionExprTree        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPermissionExprTree          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPermissionExprTree = fmt.Errorf("proto: unexpected end of group")
)
