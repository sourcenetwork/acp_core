// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sourcenetwork/acp_core/relationship.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/cosmos/gogoproto/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RegistrationResult encodes the possible result set from Registering an Object
type RegistrationResult int32

const (
	// NoOp indicates no action was take. The operation failed or the Object already existed and was active
	RegistrationResult_NoOp RegistrationResult = 0
	// Registered indicates the Object was sucessfuly registered to the Actor.
	RegistrationResult_Registered RegistrationResult = 1
	// Unarchived indicates that a previously deleted Object is active again.
	// Only the original owners can Unarchive an object.
	RegistrationResult_Unarchived RegistrationResult = 2
)

var RegistrationResult_name = map[int32]string{
	0: "NoOp",
	1: "Registered",
	2: "Unarchived",
}

var RegistrationResult_value = map[string]int32{
	"NoOp":       0,
	"Registered": 1,
	"Unarchived": 2,
}

func (x RegistrationResult) String() string {
	return proto.EnumName(RegistrationResult_name, int32(x))
}

func (RegistrationResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{0}
}

// Object represents an entity which must be access controlled within a Policy.
type Object struct {
	Resource string `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	Id       string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Object) Reset()         { *m = Object{} }
func (m *Object) String() string { return proto.CompactTextString(m) }
func (*Object) ProtoMessage()    {}
func (*Object) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{0}
}
func (m *Object) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Object.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Object) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Object.Merge(m, src)
}
func (m *Object) XXX_Size() int {
	return m.Size()
}
func (m *Object) XXX_DiscardUnknown() {
	xxx_messageInfo_Object.DiscardUnknown(m)
}

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *Object) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Actor represents an entity which makes access requests to a Policy.
type Actor struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Actor) Reset()         { *m = Actor{} }
func (m *Actor) String() string { return proto.CompactTextString(m) }
func (*Actor) ProtoMessage()    {}
func (*Actor) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{1}
}
func (m *Actor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Actor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Actor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Actor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Actor.Merge(m, src)
}
func (m *Actor) XXX_Size() int {
	return m.Size()
}
func (m *Actor) XXX_DiscardUnknown() {
	xxx_messageInfo_Actor.DiscardUnknown(m)
}

var xxx_messageInfo_Actor proto.InternalMessageInfo

func (m *Actor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// ActorSet represents a set of Actors in a Policy.
// It is specified through an Object, Relation pair, which represents
// all actors which have a relationship with given obj-rel pair.
// This expansion is recursive.
type ActorSet struct {
	Object   *Object `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	Relation string  `protobuf:"bytes,2,opt,name=relation,proto3" json:"relation,omitempty"`
}

func (m *ActorSet) Reset()         { *m = ActorSet{} }
func (m *ActorSet) String() string { return proto.CompactTextString(m) }
func (*ActorSet) ProtoMessage()    {}
func (*ActorSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{2}
}
func (m *ActorSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActorSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActorSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActorSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActorSet.Merge(m, src)
}
func (m *ActorSet) XXX_Size() int {
	return m.Size()
}
func (m *ActorSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ActorSet.DiscardUnknown(m)
}

var xxx_messageInfo_ActorSet proto.InternalMessageInfo

func (m *ActorSet) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *ActorSet) GetRelation() string {
	if m != nil {
		return m.Relation
	}
	return ""
}

// AllActors models a special Relationship Subject which indicates
// that all Actors in the Policy are included.
type AllActors struct {
}

func (m *AllActors) Reset()         { *m = AllActors{} }
func (m *AllActors) String() string { return proto.CompactTextString(m) }
func (*AllActors) ProtoMessage()    {}
func (*AllActors) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{3}
}
func (m *AllActors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllActors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllActors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllActors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllActors.Merge(m, src)
}
func (m *AllActors) XXX_Size() int {
	return m.Size()
}
func (m *AllActors) XXX_DiscardUnknown() {
	xxx_messageInfo_AllActors.DiscardUnknown(m)
}

var xxx_messageInfo_AllActors proto.InternalMessageInfo

// Subject specifies the target of a Relationship.
type Subject struct {
	// Types that are valid to be assigned to Subject:
	//
	//	*Subject_Actor
	//	*Subject_ActorSet
	//	*Subject_AllActors
	//	*Subject_Object
	Subject isSubject_Subject `protobuf_oneof:"subject"`
}

func (m *Subject) Reset()         { *m = Subject{} }
func (m *Subject) String() string { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()    {}
func (*Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{4}
}
func (m *Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject.Merge(m, src)
}
func (m *Subject) XXX_Size() int {
	return m.Size()
}
func (m *Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject.DiscardUnknown(m)
}

var xxx_messageInfo_Subject proto.InternalMessageInfo

type isSubject_Subject interface {
	isSubject_Subject()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Subject_Actor struct {
	Actor *Actor `protobuf:"bytes,1,opt,name=actor,proto3,oneof" json:"actor,omitempty"`
}
type Subject_ActorSet struct {
	ActorSet *ActorSet `protobuf:"bytes,2,opt,name=actor_set,json=actorSet,proto3,oneof" json:"actor_set,omitempty"`
}
type Subject_AllActors struct {
	AllActors *AllActors `protobuf:"bytes,3,opt,name=all_actors,json=allActors,proto3,oneof" json:"all_actors,omitempty"`
}
type Subject_Object struct {
	Object *Object `protobuf:"bytes,4,opt,name=object,proto3,oneof" json:"object,omitempty"`
}

func (*Subject_Actor) isSubject_Subject()     {}
func (*Subject_ActorSet) isSubject_Subject()  {}
func (*Subject_AllActors) isSubject_Subject() {}
func (*Subject_Object) isSubject_Subject()    {}

func (m *Subject) GetSubject() isSubject_Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *Subject) GetActor() *Actor {
	if x, ok := m.GetSubject().(*Subject_Actor); ok {
		return x.Actor
	}
	return nil
}

func (m *Subject) GetActorSet() *ActorSet {
	if x, ok := m.GetSubject().(*Subject_ActorSet); ok {
		return x.ActorSet
	}
	return nil
}

func (m *Subject) GetAllActors() *AllActors {
	if x, ok := m.GetSubject().(*Subject_AllActors); ok {
		return x.AllActors
	}
	return nil
}

func (m *Subject) GetObject() *Object {
	if x, ok := m.GetSubject().(*Subject_Object); ok {
		return x.Object
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Subject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Subject_Actor)(nil),
		(*Subject_ActorSet)(nil),
		(*Subject_AllActors)(nil),
		(*Subject_Object)(nil),
	}
}

// Relationship models an access control rule.
// It states that the given subject has relation with object.
type Relationship struct {
	Object   *Object  `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	Relation string   `protobuf:"bytes,2,opt,name=relation,proto3" json:"relation,omitempty"`
	Subject  *Subject `protobuf:"bytes,3,opt,name=subject,proto3" json:"subject,omitempty"`
}

func (m *Relationship) Reset()         { *m = Relationship{} }
func (m *Relationship) String() string { return proto.CompactTextString(m) }
func (*Relationship) ProtoMessage()    {}
func (*Relationship) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{5}
}
func (m *Relationship) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relationship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relationship.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relationship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relationship.Merge(m, src)
}
func (m *Relationship) XXX_Size() int {
	return m.Size()
}
func (m *Relationship) XXX_DiscardUnknown() {
	xxx_messageInfo_Relationship.DiscardUnknown(m)
}

var xxx_messageInfo_Relationship proto.InternalMessageInfo

func (m *Relationship) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *Relationship) GetRelation() string {
	if m != nil {
		return m.Relation
	}
	return ""
}

func (m *Relationship) GetSubject() *Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

// RelationshipRecord represents a document contained a Relationship and additional data.
type RelationshipRecord struct {
	// id of the transaction that added the policy
	TxId     string `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	PolicyId string `protobuf:"bytes,2,opt,name=policy_id,json=policyId,proto3" json:"policy_id,omitempty"`
	// actor is the DID of the Actor which created the relationship
	Actor        string        `protobuf:"bytes,3,opt,name=actor,proto3" json:"actor,omitempty"`
	Relationship *Relationship `protobuf:"bytes,4,opt,name=relationship,proto3" json:"relationship,omitempty"`
	// archived indicates whether an object has been unregistered
	Archived     bool             `protobuf:"varint,5,opt,name=archived,proto3" json:"archived,omitempty"`
	CreationTime *types.Timestamp `protobuf:"bytes,6,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
}

func (m *RelationshipRecord) Reset()         { *m = RelationshipRecord{} }
func (m *RelationshipRecord) String() string { return proto.CompactTextString(m) }
func (*RelationshipRecord) ProtoMessage()    {}
func (*RelationshipRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{6}
}
func (m *RelationshipRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationshipRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationshipRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelationshipRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationshipRecord.Merge(m, src)
}
func (m *RelationshipRecord) XXX_Size() int {
	return m.Size()
}
func (m *RelationshipRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationshipRecord.DiscardUnknown(m)
}

var xxx_messageInfo_RelationshipRecord proto.InternalMessageInfo

func (m *RelationshipRecord) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *RelationshipRecord) GetPolicyId() string {
	if m != nil {
		return m.PolicyId
	}
	return ""
}

func (m *RelationshipRecord) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *RelationshipRecord) GetRelationship() *Relationship {
	if m != nil {
		return m.Relationship
	}
	return nil
}

func (m *RelationshipRecord) GetArchived() bool {
	if m != nil {
		return m.Archived
	}
	return false
}

func (m *RelationshipRecord) GetCreationTime() *types.Timestamp {
	if m != nil {
		return m.CreationTime
	}
	return nil
}

// Registration represents a record assigning an Object as being owned by an Actor
type Registration struct {
	Object *Object `protobuf:"bytes,1,opt,name=object,proto3" json:"object,omitempty"`
	Actor  *Actor  `protobuf:"bytes,2,opt,name=actor,proto3" json:"actor,omitempty"`
}

func (m *Registration) Reset()         { *m = Registration{} }
func (m *Registration) String() string { return proto.CompactTextString(m) }
func (*Registration) ProtoMessage()    {}
func (*Registration) Descriptor() ([]byte, []int) {
	return fileDescriptor_35216beba2308723, []int{7}
}
func (m *Registration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Registration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Registration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Registration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Registration.Merge(m, src)
}
func (m *Registration) XXX_Size() int {
	return m.Size()
}
func (m *Registration) XXX_DiscardUnknown() {
	xxx_messageInfo_Registration.DiscardUnknown(m)
}

var xxx_messageInfo_Registration proto.InternalMessageInfo

func (m *Registration) GetObject() *Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *Registration) GetActor() *Actor {
	if m != nil {
		return m.Actor
	}
	return nil
}

func init() {
	proto.RegisterEnum("sourcenetwork.acp_core.RegistrationResult", RegistrationResult_name, RegistrationResult_value)
	proto.RegisterType((*Object)(nil), "sourcenetwork.acp_core.Object")
	proto.RegisterType((*Actor)(nil), "sourcenetwork.acp_core.Actor")
	proto.RegisterType((*ActorSet)(nil), "sourcenetwork.acp_core.ActorSet")
	proto.RegisterType((*AllActors)(nil), "sourcenetwork.acp_core.AllActors")
	proto.RegisterType((*Subject)(nil), "sourcenetwork.acp_core.Subject")
	proto.RegisterType((*Relationship)(nil), "sourcenetwork.acp_core.Relationship")
	proto.RegisterType((*RelationshipRecord)(nil), "sourcenetwork.acp_core.RelationshipRecord")
	proto.RegisterType((*Registration)(nil), "sourcenetwork.acp_core.Registration")
}

func init() {
	proto.RegisterFile("sourcenetwork/acp_core/relationship.proto", fileDescriptor_35216beba2308723)
}

var fileDescriptor_35216beba2308723 = []byte{
	// 549 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xb6, 0xdd, 0x26, 0xb5, 0x27, 0xa1, 0x8a, 0x16, 0x04, 0x51, 0x10, 0x6e, 0xb0, 0x38, 0x14,
	0x90, 0x6c, 0xa9, 0x05, 0x04, 0x17, 0xaa, 0x46, 0x42, 0x4a, 0x2f, 0x54, 0xda, 0xc0, 0x85, 0x03,
	0x96, 0x63, 0x2f, 0x89, 0xa9, 0x93, 0xb5, 0xd6, 0x1b, 0x68, 0xc5, 0x91, 0x1b, 0x27, 0x5e, 0x80,
	0xf7, 0xe1, 0xd8, 0x23, 0x47, 0x94, 0xbc, 0x08, 0xf2, 0xfe, 0x98, 0x44, 0xc2, 0xa8, 0x42, 0xe2,
	0xe6, 0xd9, 0xf9, 0xf9, 0xbe, 0xf9, 0x66, 0xc6, 0x70, 0xbf, 0xa0, 0x0b, 0x16, 0x93, 0x39, 0xe1,
	0x1f, 0x29, 0x3b, 0x0b, 0xa2, 0x38, 0x0f, 0x63, 0xca, 0x48, 0xc0, 0x48, 0x16, 0xf1, 0x94, 0xce,
	0x8b, 0x69, 0x9a, 0xfb, 0x39, 0xa3, 0x9c, 0xa2, 0x9b, 0x1b, 0xa1, 0xbe, 0x0e, 0xed, 0xed, 0x4d,
	0x28, 0x9d, 0x64, 0x24, 0x10, 0x51, 0xe3, 0xc5, 0xbb, 0x80, 0xa7, 0x33, 0x52, 0xf0, 0x68, 0xa6,
	0x12, 0xbd, 0x47, 0xd0, 0x3c, 0x1d, 0xbf, 0x27, 0x31, 0x47, 0x3d, 0xb0, 0x19, 0x91, 0x65, 0xba,
	0x66, 0xdf, 0xdc, 0x77, 0x70, 0x65, 0xa3, 0x5d, 0xb0, 0xd2, 0xa4, 0x6b, 0x89, 0x57, 0x2b, 0x4d,
	0xbc, 0x5b, 0xd0, 0x38, 0x8e, 0x39, 0x65, 0xca, 0x61, 0x56, 0x8e, 0xb7, 0x60, 0x0b, 0xc7, 0x88,
	0x70, 0xf4, 0x04, 0x9a, 0x54, 0x94, 0x16, 0xfe, 0xd6, 0x81, 0xeb, 0xff, 0x99, 0xa4, 0x2f, 0x09,
	0x60, 0x15, 0x2d, 0x89, 0xc8, 0x0e, 0x15, 0x64, 0x65, 0x7b, 0x2d, 0x70, 0x8e, 0xb3, 0x4c, 0x40,
	0x14, 0xde, 0x17, 0x0b, 0x76, 0x46, 0x0b, 0x99, 0xf4, 0x18, 0x1a, 0x51, 0xf9, 0xaa, 0xb0, 0xee,
	0xd4, 0x61, 0x89, 0xd4, 0xa1, 0x81, 0x65, 0x34, 0x3a, 0x02, 0x47, 0x7c, 0x84, 0x05, 0xe1, 0x02,
	0xac, 0x75, 0xd0, 0xff, 0x6b, 0xea, 0x88, 0xf0, 0xa1, 0x81, 0xed, 0x48, 0x37, 0x39, 0x00, 0x88,
	0xb2, 0x2c, 0x14, 0x76, 0xd1, 0xdd, 0x12, 0x15, 0xee, 0xd6, 0x56, 0xd0, 0xd4, 0x87, 0x06, 0x76,
	0x22, 0x6d, 0xa0, 0xa7, 0x95, 0x50, 0xdb, 0x57, 0x11, 0x6a, 0x68, 0x68, 0xa9, 0x06, 0x0e, 0xec,
	0x14, 0x52, 0x00, 0xef, 0x9b, 0x09, 0x6d, 0xbc, 0xb6, 0x18, 0xff, 0x43, 0x7e, 0xf4, 0xac, 0xc2,
	0x53, 0xad, 0xee, 0xd5, 0x15, 0x55, 0x73, 0xc1, 0x15, 0xbf, 0xcf, 0x16, 0xa0, 0x75, 0x7e, 0x98,
	0xc4, 0x94, 0x25, 0xe8, 0x3a, 0x34, 0xf8, 0x79, 0x58, 0xed, 0xd0, 0x36, 0x3f, 0x3f, 0x49, 0xd0,
	0x6d, 0x70, 0x72, 0x9a, 0xa5, 0xf1, 0x45, 0x58, 0x6d, 0x9d, 0x2d, 0x1f, 0x4e, 0x12, 0x74, 0x43,
	0x4f, 0x7a, 0x4b, 0x38, 0xd4, 0x20, 0x87, 0xd0, 0x5e, 0x3f, 0x0b, 0xa5, 0xe4, 0xbd, 0x3a, 0x7a,
	0x1b, 0x4c, 0x36, 0x32, 0xcb, 0xfe, 0x23, 0x16, 0x4f, 0xd3, 0x0f, 0x24, 0xe9, 0x36, 0xfa, 0xe6,
	0xbe, 0x8d, 0x2b, 0x1b, 0x1d, 0xc1, 0xb5, 0x98, 0x11, 0x11, 0x1b, 0x96, 0x97, 0xd4, 0x6d, 0x0a,
	0x98, 0x9e, 0x2f, 0xcf, 0xcc, 0xd7, 0x67, 0xe6, 0xbf, 0xd2, 0x67, 0x86, 0xdb, 0x3a, 0xa1, 0x7c,
	0xf2, 0x3e, 0x95, 0x43, 0x9a, 0xa4, 0x05, 0x67, 0x52, 0xd0, 0x7f, 0x1d, 0xd2, 0xa1, 0x16, 0xc1,
	0xba, 0xc2, 0xba, 0x2b, 0x8d, 0x1e, 0x3c, 0x2f, 0x27, 0xf0, 0x1b, 0x1c, 0x93, 0x62, 0x91, 0x71,
	0x64, 0xc3, 0xf6, 0x4b, 0x7a, 0x9a, 0x77, 0x0c, 0xb4, 0x0b, 0x20, 0xfd, 0x84, 0x91, 0xa4, 0x63,
	0x96, 0xf6, 0xeb, 0xb9, 0xee, 0xbd, 0x63, 0x0d, 0x5e, 0x7c, 0x5f, 0xba, 0xe6, 0xe5, 0xd2, 0x35,
	0x7f, 0x2e, 0x5d, 0xf3, 0xeb, 0xca, 0x35, 0x2e, 0x57, 0xae, 0xf1, 0x63, 0xe5, 0x1a, 0x6f, 0x1e,
	0x4e, 0x52, 0x3e, 0x5d, 0x8c, 0xfd, 0x98, 0xce, 0x82, 0x9a, 0x9f, 0x56, 0x7e, 0x36, 0x09, 0xf8,
	0x45, 0x4e, 0x8a, 0x71, 0x53, 0xa8, 0x74, 0xf8, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x07, 0x06, 0xc8,
	0x35, 0xdf, 0x04, 0x00, 0x00,
}

func (m *Object) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Actor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Actor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Actor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActorSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relation) > 0 {
		i -= len(m.Relation)
		copy(dAtA[i:], m.Relation)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.Relation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllActors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllActors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllActors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subject != nil {
		{
			size := m.Subject.Size()
			i -= size
			if _, err := m.Subject.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Subject_Actor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_Actor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Actor != nil {
		{
			size, err := m.Actor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Subject_ActorSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_ActorSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ActorSet != nil {
		{
			size, err := m.ActorSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Subject_AllActors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_AllActors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllActors != nil {
		{
			size, err := m.AllActors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Subject_Object) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject_Object) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Relationship) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relationship) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relationship) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subject != nil {
		{
			size, err := m.Subject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Relation) > 0 {
		i -= len(m.Relation)
		copy(dAtA[i:], m.Relation)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.Relation)))
		i--
		dAtA[i] = 0x12
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelationshipRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationshipRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelationshipRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationTime != nil {
		{
			size, err := m.CreationTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Archived {
		i--
		if m.Archived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Relationship != nil {
		{
			size, err := m.Relationship.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PolicyId) > 0 {
		i -= len(m.PolicyId)
		copy(dAtA[i:], m.PolicyId)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.PolicyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintRelationship(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Registration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Registration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Registration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Actor != nil {
		{
			size, err := m.Actor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Object != nil {
		{
			size, err := m.Object.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelationship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRelationship(dAtA []byte, offset int, v uint64) int {
	offset -= sovRelationship(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}

func (m *Actor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}

func (m *ActorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	l = len(m.Relation)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}

func (m *AllActors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subject != nil {
		n += m.Subject.Size()
	}
	return n
}

func (m *Subject_Actor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Actor != nil {
		l = m.Actor.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}
func (m *Subject_ActorSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActorSet != nil {
		l = m.ActorSet.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}
func (m *Subject_AllActors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllActors != nil {
		l = m.AllActors.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}
func (m *Subject_Object) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}
func (m *Relationship) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	l = len(m.Relation)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	if m.Subject != nil {
		l = m.Subject.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}

func (m *RelationshipRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	l = len(m.PolicyId)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovRelationship(uint64(l))
	}
	if m.Relationship != nil {
		l = m.Relationship.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	if m.Archived {
		n += 2
	}
	if m.CreationTime != nil {
		l = m.CreationTime.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}

func (m *Registration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	if m.Actor != nil {
		l = m.Actor.Size()
		n += 1 + l + sovRelationship(uint64(l))
	}
	return n
}

func sovRelationship(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRelationship(x uint64) (n int) {
	return sovRelationship(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Object) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Object: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Object: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Actor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Actor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Actor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActorSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllActors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllActors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllActors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Actor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subject = &Subject_Actor{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActorSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ActorSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subject = &Subject_ActorSet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllActors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AllActors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subject = &Subject_AllActors{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Object{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Subject = &Subject_Object{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relationship) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relationship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relationship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subject == nil {
				m.Subject = &Subject{}
			}
			if err := m.Subject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationshipRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationshipRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationshipRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relationship", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Relationship == nil {
				m.Relationship = &Relationship{}
			}
			if err := m.Relationship.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Archived = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTime == nil {
				m.CreationTime = &types.Timestamp{}
			}
			if err := m.CreationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Registration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Registration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Registration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Object{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelationship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelationship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Actor == nil {
				m.Actor = &Actor{}
			}
			if err := m.Actor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelationship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelationship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRelationship(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRelationship
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelationship
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRelationship
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRelationship
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRelationship
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRelationship        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRelationship          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRelationship = fmt.Errorf("proto: unexpected end of group")
)
