package relationship

import (
	"context"

	"github.com/sourcenetwork/acp_core/internal/zanzi"
	"github.com/sourcenetwork/acp_core/pkg/errors"
	"github.com/sourcenetwork/acp_core/pkg/types"
)

func NewRelationshipAuthorizer(engine *zanzi.Adapter) *RelationshipAuthorizer {
	return &RelationshipAuthorizer{
		engine: engine,
	}
}

// RelationshipAuthorizer acts as an Authorization Request engine
// which validates whether a Relationship can be set or deleted by an Actor.
//
// The Permission evaluation is done through a Check call using the auxiliary permissions
// auto generated by the ACP module and attached to a permission.
//
// For instance, take the Relationship (obj:foo, reader, steve) being submitted by Actor Bob.
// Bob is allowed to Create that relationship if and only if:
// Bob has the permission _can_manage_reader for "obj:foo".
type RelationshipAuthorizer struct {
	engine *zanzi.Adapter
}

// IsAuthorized validates whether actor is a manager for the given relationship.
//
// A given Relationship is only valid if for the Relationship's Object and Relation
// the Actor has an associated permission to manage the Object, Relation pair.
func (a *RelationshipAuthorizer) IsAuthorized(ctx context.Context, policy *types.Policy, operation *types.Operation, actor *types.Actor) (bool, error) {
	resource := policy.GetResourceByName(operation.Object.Resource)
	if resource == nil {
		return false, errors.New("resource not found in policy", errors.ErrorType_NOT_FOUND,
			errors.Pair("policy", policy.Id),
			errors.Pair("resource", operation.Object.Resource),
		)
	}
	relation := resource.GetRelationByName(operation.Permission)
	if relation == nil {
		return false, errors.New("relation not found in resource", errors.ErrorType_NOT_FOUND,
			errors.Pair("policy", policy.Id),
			errors.Pair("resource", operation.Object.Resource),
			errors.Pair("relation", operation.Permission),
		)
	}

	authRequest := &types.Operation{
		Object:     operation.Object,
		Permission: policy.GetManagementPermissionName(operation.Permission),
	}

	return a.engine.Check(ctx, policy, authRequest, actor)
}
