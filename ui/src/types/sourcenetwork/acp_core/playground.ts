// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: sourcenetwork/acp_core/playground.proto

/* eslint-disable */
import { BinaryReader } from "@bufbuild/protobuf/wire";
import { PolicyCatalogue } from "./catalogue";
import { SandboxData, SandboxDataErrors, SandboxRecord } from "./sandbox";
import { AnnotatedPolicyTheoremResult } from "./theorem";

export const protobufPackage = "sourcenetwork.acp_core";

export interface NewSandboxRequest {
  /** user defined name for the sandbox */
  name: string;
  /** optional description for documentation */
  description: string;
}

export interface NewSandboxResponse {
  /** record modeling the created sandbox */
  record: SandboxRecord | undefined;
}

export interface SetStateRequest {
  /** handle to an existing sandbox */
  handle: number;
  /** data to set in the sandbox */
  data: SandboxData | undefined;
}

export interface SetStateResponse {
  /** ok indicates the state updated sucessfuly */
  ok: boolean;
  /** errors represent all recoverable errors found while parsing and setting the sandbox state */
  errors:
    | SandboxDataErrors
    | undefined;
  /** record contains a representation of the sandbox's new internal state */
  record: SandboxRecord | undefined;
}

export interface GetCatalogueRequest {
  /** handle to an existing sandbox */
  handle: number;
}

export interface GetCatalogueResponse {
  /** catalogue for the state of the given sandbox */
  catalogue: PolicyCatalogue | undefined;
}

export interface VerifyTheoremsRequest {
  /** handle to an existing sandbox */
  handle: number;
}

export interface VerifyTheoremsResponse {
  /** result of the provided sandbox theorem */
  result: AnnotatedPolicyTheoremResult | undefined;
}

export interface ListSandboxesRequest {
}

export interface ListSandboxesResponse {
  /** records contains all sandboxes that exist in a playground */
  records: SandboxRecord[];
}

export interface RestoreScratchpadRequest {
  /** handle to an existing sandbox */
  handle: number;
}

export interface RestoreScratchpadResponse {
  /** scratchpad contains the data in the restored scratchpad */
  scratchpad: SandboxData | undefined;
}

export interface SimulateRequest {
  /** data to set in the sandbox */
  data: SandboxData | undefined;
}

export interface SimulateReponse {
  /** validate_data flags whether the input SandboxData was sucessfuly loaded */
  validData: boolean;
  /** errors represent all recoverable errors found while parsing and setting the sandbox state */
  errors:
    | SandboxDataErrors
    | undefined;
  /** record contains a representation of the sandbox's new internal state */
  record:
    | SandboxRecord
    | undefined;
  /** result of the provided sandbox theorem */
  result: AnnotatedPolicyTheoremResult | undefined;
}

export interface GetSandboxRequest {
  /** handle to an existing sandbox */
  handle: number;
}

export interface GetSandboxResponse {
  /** record contains a representation of the sandbox's new internal state */
  record: SandboxRecord | undefined;
}

function createBaseNewSandboxRequest(): NewSandboxRequest {
  return { name: "", description: "" };
}

export const NewSandboxRequest: MessageFns<NewSandboxRequest> = {
  fromJSON(object: any): NewSandboxRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: NewSandboxRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewSandboxRequest>, I>>(base?: I): NewSandboxRequest {
    return NewSandboxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewSandboxRequest>, I>>(object: I): NewSandboxRequest {
    const message = createBaseNewSandboxRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseNewSandboxResponse(): NewSandboxResponse {
  return { record: undefined };
}

export const NewSandboxResponse: MessageFns<NewSandboxResponse> = {
  fromJSON(object: any): NewSandboxResponse {
    return { record: isSet(object.record) ? SandboxRecord.fromJSON(object.record) : undefined };
  },

  toJSON(message: NewSandboxResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = SandboxRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewSandboxResponse>, I>>(base?: I): NewSandboxResponse {
    return NewSandboxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewSandboxResponse>, I>>(object: I): NewSandboxResponse {
    const message = createBaseNewSandboxResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? SandboxRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseSetStateRequest(): SetStateRequest {
  return { handle: 0, data: undefined };
}

export const SetStateRequest: MessageFns<SetStateRequest> = {
  fromJSON(object: any): SetStateRequest {
    return {
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      data: isSet(object.data) ? SandboxData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: SetStateRequest): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.data !== undefined) {
      obj.data = SandboxData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetStateRequest>, I>>(base?: I): SetStateRequest {
    return SetStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetStateRequest>, I>>(object: I): SetStateRequest {
    const message = createBaseSetStateRequest();
    message.handle = object.handle ?? 0;
    message.data = (object.data !== undefined && object.data !== null)
      ? SandboxData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseSetStateResponse(): SetStateResponse {
  return { ok: false, errors: undefined, record: undefined };
}

export const SetStateResponse: MessageFns<SetStateResponse> = {
  fromJSON(object: any): SetStateResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      errors: isSet(object.errors) ? SandboxDataErrors.fromJSON(object.errors) : undefined,
      record: isSet(object.record) ? SandboxRecord.fromJSON(object.record) : undefined,
    };
  },

  toJSON(message: SetStateResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.errors !== undefined) {
      obj.errors = SandboxDataErrors.toJSON(message.errors);
    }
    if (message.record !== undefined) {
      obj.record = SandboxRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetStateResponse>, I>>(base?: I): SetStateResponse {
    return SetStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetStateResponse>, I>>(object: I): SetStateResponse {
    const message = createBaseSetStateResponse();
    message.ok = object.ok ?? false;
    message.errors = (object.errors !== undefined && object.errors !== null)
      ? SandboxDataErrors.fromPartial(object.errors)
      : undefined;
    message.record = (object.record !== undefined && object.record !== null)
      ? SandboxRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseGetCatalogueRequest(): GetCatalogueRequest {
  return { handle: 0 };
}

export const GetCatalogueRequest: MessageFns<GetCatalogueRequest> = {
  fromJSON(object: any): GetCatalogueRequest {
    return { handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0 };
  },

  toJSON(message: GetCatalogueRequest): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCatalogueRequest>, I>>(base?: I): GetCatalogueRequest {
    return GetCatalogueRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCatalogueRequest>, I>>(object: I): GetCatalogueRequest {
    const message = createBaseGetCatalogueRequest();
    message.handle = object.handle ?? 0;
    return message;
  },
};

function createBaseGetCatalogueResponse(): GetCatalogueResponse {
  return { catalogue: undefined };
}

export const GetCatalogueResponse: MessageFns<GetCatalogueResponse> = {
  fromJSON(object: any): GetCatalogueResponse {
    return { catalogue: isSet(object.catalogue) ? PolicyCatalogue.fromJSON(object.catalogue) : undefined };
  },

  toJSON(message: GetCatalogueResponse): unknown {
    const obj: any = {};
    if (message.catalogue !== undefined) {
      obj.catalogue = PolicyCatalogue.toJSON(message.catalogue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCatalogueResponse>, I>>(base?: I): GetCatalogueResponse {
    return GetCatalogueResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCatalogueResponse>, I>>(object: I): GetCatalogueResponse {
    const message = createBaseGetCatalogueResponse();
    message.catalogue = (object.catalogue !== undefined && object.catalogue !== null)
      ? PolicyCatalogue.fromPartial(object.catalogue)
      : undefined;
    return message;
  },
};

function createBaseVerifyTheoremsRequest(): VerifyTheoremsRequest {
  return { handle: 0 };
}

export const VerifyTheoremsRequest: MessageFns<VerifyTheoremsRequest> = {
  fromJSON(object: any): VerifyTheoremsRequest {
    return { handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0 };
  },

  toJSON(message: VerifyTheoremsRequest): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyTheoremsRequest>, I>>(base?: I): VerifyTheoremsRequest {
    return VerifyTheoremsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyTheoremsRequest>, I>>(object: I): VerifyTheoremsRequest {
    const message = createBaseVerifyTheoremsRequest();
    message.handle = object.handle ?? 0;
    return message;
  },
};

function createBaseVerifyTheoremsResponse(): VerifyTheoremsResponse {
  return { result: undefined };
}

export const VerifyTheoremsResponse: MessageFns<VerifyTheoremsResponse> = {
  fromJSON(object: any): VerifyTheoremsResponse {
    return { result: isSet(object.result) ? AnnotatedPolicyTheoremResult.fromJSON(object.result) : undefined };
  },

  toJSON(message: VerifyTheoremsResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = AnnotatedPolicyTheoremResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyTheoremsResponse>, I>>(base?: I): VerifyTheoremsResponse {
    return VerifyTheoremsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyTheoremsResponse>, I>>(object: I): VerifyTheoremsResponse {
    const message = createBaseVerifyTheoremsResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? AnnotatedPolicyTheoremResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseListSandboxesRequest(): ListSandboxesRequest {
  return {};
}

export const ListSandboxesRequest: MessageFns<ListSandboxesRequest> = {
  fromJSON(_: any): ListSandboxesRequest {
    return {};
  },

  toJSON(_: ListSandboxesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSandboxesRequest>, I>>(base?: I): ListSandboxesRequest {
    return ListSandboxesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSandboxesRequest>, I>>(_: I): ListSandboxesRequest {
    const message = createBaseListSandboxesRequest();
    return message;
  },
};

function createBaseListSandboxesResponse(): ListSandboxesResponse {
  return { records: [] };
}

export const ListSandboxesResponse: MessageFns<ListSandboxesResponse> = {
  fromJSON(object: any): ListSandboxesResponse {
    return {
      records: globalThis.Array.isArray(object?.records)
        ? object.records.map((e: any) => SandboxRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSandboxesResponse): unknown {
    const obj: any = {};
    if (message.records?.length) {
      obj.records = message.records.map((e) => SandboxRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSandboxesResponse>, I>>(base?: I): ListSandboxesResponse {
    return ListSandboxesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSandboxesResponse>, I>>(object: I): ListSandboxesResponse {
    const message = createBaseListSandboxesResponse();
    message.records = object.records?.map((e) => SandboxRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRestoreScratchpadRequest(): RestoreScratchpadRequest {
  return { handle: 0 };
}

export const RestoreScratchpadRequest: MessageFns<RestoreScratchpadRequest> = {
  fromJSON(object: any): RestoreScratchpadRequest {
    return { handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0 };
  },

  toJSON(message: RestoreScratchpadRequest): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestoreScratchpadRequest>, I>>(base?: I): RestoreScratchpadRequest {
    return RestoreScratchpadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestoreScratchpadRequest>, I>>(object: I): RestoreScratchpadRequest {
    const message = createBaseRestoreScratchpadRequest();
    message.handle = object.handle ?? 0;
    return message;
  },
};

function createBaseRestoreScratchpadResponse(): RestoreScratchpadResponse {
  return { scratchpad: undefined };
}

export const RestoreScratchpadResponse: MessageFns<RestoreScratchpadResponse> = {
  fromJSON(object: any): RestoreScratchpadResponse {
    return { scratchpad: isSet(object.scratchpad) ? SandboxData.fromJSON(object.scratchpad) : undefined };
  },

  toJSON(message: RestoreScratchpadResponse): unknown {
    const obj: any = {};
    if (message.scratchpad !== undefined) {
      obj.scratchpad = SandboxData.toJSON(message.scratchpad);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestoreScratchpadResponse>, I>>(base?: I): RestoreScratchpadResponse {
    return RestoreScratchpadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestoreScratchpadResponse>, I>>(object: I): RestoreScratchpadResponse {
    const message = createBaseRestoreScratchpadResponse();
    message.scratchpad = (object.scratchpad !== undefined && object.scratchpad !== null)
      ? SandboxData.fromPartial(object.scratchpad)
      : undefined;
    return message;
  },
};

function createBaseSimulateRequest(): SimulateRequest {
  return { data: undefined };
}

export const SimulateRequest: MessageFns<SimulateRequest> = {
  fromJSON(object: any): SimulateRequest {
    return { data: isSet(object.data) ? SandboxData.fromJSON(object.data) : undefined };
  },

  toJSON(message: SimulateRequest): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = SandboxData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulateRequest>, I>>(base?: I): SimulateRequest {
    return SimulateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulateRequest>, I>>(object: I): SimulateRequest {
    const message = createBaseSimulateRequest();
    message.data = (object.data !== undefined && object.data !== null)
      ? SandboxData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseSimulateReponse(): SimulateReponse {
  return { validData: false, errors: undefined, record: undefined, result: undefined };
}

export const SimulateReponse: MessageFns<SimulateReponse> = {
  fromJSON(object: any): SimulateReponse {
    return {
      validData: isSet(object.validData) ? globalThis.Boolean(object.validData) : false,
      errors: isSet(object.errors) ? SandboxDataErrors.fromJSON(object.errors) : undefined,
      record: isSet(object.record) ? SandboxRecord.fromJSON(object.record) : undefined,
      result: isSet(object.result) ? AnnotatedPolicyTheoremResult.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: SimulateReponse): unknown {
    const obj: any = {};
    if (message.validData !== false) {
      obj.validData = message.validData;
    }
    if (message.errors !== undefined) {
      obj.errors = SandboxDataErrors.toJSON(message.errors);
    }
    if (message.record !== undefined) {
      obj.record = SandboxRecord.toJSON(message.record);
    }
    if (message.result !== undefined) {
      obj.result = AnnotatedPolicyTheoremResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulateReponse>, I>>(base?: I): SimulateReponse {
    return SimulateReponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulateReponse>, I>>(object: I): SimulateReponse {
    const message = createBaseSimulateReponse();
    message.validData = object.validData ?? false;
    message.errors = (object.errors !== undefined && object.errors !== null)
      ? SandboxDataErrors.fromPartial(object.errors)
      : undefined;
    message.record = (object.record !== undefined && object.record !== null)
      ? SandboxRecord.fromPartial(object.record)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? AnnotatedPolicyTheoremResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetSandboxRequest(): GetSandboxRequest {
  return { handle: 0 };
}

export const GetSandboxRequest: MessageFns<GetSandboxRequest> = {
  fromJSON(object: any): GetSandboxRequest {
    return { handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0 };
  },

  toJSON(message: GetSandboxRequest): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSandboxRequest>, I>>(base?: I): GetSandboxRequest {
    return GetSandboxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSandboxRequest>, I>>(object: I): GetSandboxRequest {
    const message = createBaseGetSandboxRequest();
    message.handle = object.handle ?? 0;
    return message;
  },
};

function createBaseGetSandboxResponse(): GetSandboxResponse {
  return { record: undefined };
}

export const GetSandboxResponse: MessageFns<GetSandboxResponse> = {
  fromJSON(object: any): GetSandboxResponse {
    return { record: isSet(object.record) ? SandboxRecord.fromJSON(object.record) : undefined };
  },

  toJSON(message: GetSandboxResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = SandboxRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSandboxResponse>, I>>(base?: I): GetSandboxResponse {
    return GetSandboxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSandboxResponse>, I>>(object: I): GetSandboxResponse {
    const message = createBaseGetSandboxResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? SandboxRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

export interface PlaygroundService {
  /**
   * NewSandbox creates a new isolated execution environment in the Service
   * Returns a handle which references the sandbox
   */
  NewSandbox(request: NewSandboxRequest): Promise<NewSandboxResponse>;
  /** ListSandboxes returns the list of sandboxes created in the Playgruond */
  ListSandboxes(request: ListSandboxesRequest): Promise<ListSandboxesResponse>;
  /** SetState updates the state of a Sandbox environment with the newly provided data */
  SetState(request: SetStateRequest): Promise<SetStateResponse>;
  /** RestoreScratchpad restores the data in scratchpad to match the currently loaded sandbox state */
  RestoreScratchpad(request: RestoreScratchpadRequest): Promise<RestoreScratchpadResponse>;
  /** GetCatalogue returns the catalogue (index/LUT) of defined entities within a sandbox */
  GetCatalogue(request: GetCatalogueRequest): Promise<GetCatalogueResponse>;
  /** GetSandbox returns the internal sandbox state of a sandbox */
  GetSandbox(request: GetSandboxRequest): Promise<GetSandboxResponse>;
  /** VerifyTheorems executes the defined test suite for a sandbox */
  VerifyTheorems(request: VerifyTheoremsRequest): Promise<VerifyTheoremsResponse>;
  /**
   * Simulate receives Sandbox state data and a theorem, creates an ephemeral sandbox
   * evaluates the given theorem against the sandbox's policy and returns the result
   * Simulate is a oneshot operation and persists no state in the process.
   */
  Simulate(request: SimulateRequest): Promise<SimulateReponse>;
}

export const PlaygroundServiceServiceName = "sourcenetwork.acp_core.PlaygroundService";
export class PlaygroundServiceClientImpl implements PlaygroundService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || PlaygroundServiceServiceName;
    this.rpc = rpc;
    this.NewSandbox = this.NewSandbox.bind(this);
    this.ListSandboxes = this.ListSandboxes.bind(this);
    this.SetState = this.SetState.bind(this);
    this.RestoreScratchpad = this.RestoreScratchpad.bind(this);
    this.GetCatalogue = this.GetCatalogue.bind(this);
    this.GetSandbox = this.GetSandbox.bind(this);
    this.VerifyTheorems = this.VerifyTheorems.bind(this);
    this.Simulate = this.Simulate.bind(this);
  }
  NewSandbox(request: NewSandboxRequest): Promise<NewSandboxResponse> {
    const data = NewSandboxRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NewSandbox", data);
    return promise.then((data) => NewSandboxResponse.decode(new BinaryReader(data)));
  }

  ListSandboxes(request: ListSandboxesRequest): Promise<ListSandboxesResponse> {
    const data = ListSandboxesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSandboxes", data);
    return promise.then((data) => ListSandboxesResponse.decode(new BinaryReader(data)));
  }

  SetState(request: SetStateRequest): Promise<SetStateResponse> {
    const data = SetStateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetState", data);
    return promise.then((data) => SetStateResponse.decode(new BinaryReader(data)));
  }

  RestoreScratchpad(request: RestoreScratchpadRequest): Promise<RestoreScratchpadResponse> {
    const data = RestoreScratchpadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RestoreScratchpad", data);
    return promise.then((data) => RestoreScratchpadResponse.decode(new BinaryReader(data)));
  }

  GetCatalogue(request: GetCatalogueRequest): Promise<GetCatalogueResponse> {
    const data = GetCatalogueRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCatalogue", data);
    return promise.then((data) => GetCatalogueResponse.decode(new BinaryReader(data)));
  }

  GetSandbox(request: GetSandboxRequest): Promise<GetSandboxResponse> {
    const data = GetSandboxRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSandbox", data);
    return promise.then((data) => GetSandboxResponse.decode(new BinaryReader(data)));
  }

  VerifyTheorems(request: VerifyTheoremsRequest): Promise<VerifyTheoremsResponse> {
    const data = VerifyTheoremsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerifyTheorems", data);
    return promise.then((data) => VerifyTheoremsResponse.decode(new BinaryReader(data)));
  }

  Simulate(request: SimulateRequest): Promise<SimulateReponse> {
    const data = SimulateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Simulate", data);
    return promise.then((data) => SimulateReponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
