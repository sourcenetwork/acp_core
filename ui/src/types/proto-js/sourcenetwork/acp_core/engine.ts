// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: sourcenetwork/acp_core/engine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { AccessRequest } from "./access_decision";
import { PolicyCatalogue } from "./catalogue";
import { Policy } from "./policy";
import { PolicyMarshalingType, policyMarshalingTypeFromJSON, policyMarshalingTypeToJSON } from "./policy_short";
import { Actor, Object, Relationship, RelationshipRecord } from "./relationship";
import { RelationshipSelector } from "./relationship_selector";
import { Params } from "./system";
import { AnnotatedPolicyTheoremResult } from "./theorem";

export const protobufPackage = "sourcenetwork.acp_core";

export interface CreatePolicyRequest {
  policy: string;
  marshalType: PolicyMarshalingType;
  /**
   * attributes is a map of attributes which can be used to store
   * caller supplied satellite data
   */
  attributes: { [key: string]: string };
}

export interface CreatePolicyRequest_AttributesEntry {
  key: string;
  value: string;
}

export interface CreatePolicyResponse {
  policy: Policy | undefined;
  attributes: { [key: string]: string };
}

export interface CreatePolicyResponse_AttributesEntry {
  key: string;
  value: string;
}

export interface SetRelationshipRequest {
  policyId: string;
  relationship:
    | Relationship
    | undefined;
  /**
   * attributes is a map of attributes which can be used to store
   * caller supplied satellite data
   */
  attributes: { [key: string]: string };
}

export interface SetRelationshipRequest_AttributesEntry {
  key: string;
  value: string;
}

export interface SetRelationshipResponse {
  /** Indicates whether the given Relationship previously existed, ie the Tx was a no op */
  recordExisted: boolean;
  record: RelationshipRecord | undefined;
}

export interface DeleteRelationshipRequest {
  policyId: string;
  relationship: Relationship | undefined;
}

export interface DeleteRelationshipResponse {
  recordFound: boolean;
}

export interface RegisterObjectRequest {
  policyId: string;
  object:
    | Object
    | undefined;
  /**
   * attributes is a map of attributes which can be used to store
   * caller supplied satellite data
   */
  attributes: { [key: string]: string };
}

export interface RegisterObjectRequest_AttributesEntry {
  key: string;
  value: string;
}

export interface RegisterObjectResponse {
  record: RelationshipRecord | undefined;
}

export interface ArchiveObjectRequest {
  policyId: string;
  object: Object | undefined;
}

export interface ArchiveObjectResponse {
  relationshipsRemoved: number;
  recordModified: boolean;
}

export interface GetObjectRegistrationRequest {
  policyId: string;
  object: Object | undefined;
}

export interface GetObjectRegistrationResponse {
  isRegistered: boolean;
  ownerId: string;
  record: RelationshipRecord | undefined;
}

export interface FilterRelationshipsRequest {
  policyId: string;
  selector: RelationshipSelector | undefined;
}

export interface FilterRelationshipsResponse {
  records: RelationshipRecord[];
}

export interface GetPolicyRequest {
  /** id of the Policy to be fetched */
  id: string;
}

export interface GetPolicyResponse {
  policy:
    | Policy
    | undefined;
  /**
   * policy_raw contains the raw policy document the user submitted to create
   * the policy
   */
  policyRaw: string;
  /** marshal_type flags the format of policy_raw */
  marshalType: PolicyMarshalingType;
}

export interface ListPoliciesRequest {
}

export interface ListPoliciesResponse {
  policies: Policy[];
}

export interface DeletePolicyRequest {
  id: string;
}

export interface DeletePolicyResponse {
  found: boolean;
}

export interface TransferObjectRequest {
  policyId: string;
  object: Object | undefined;
  newOwner: Actor | undefined;
}

export interface TransferObjectResponse {
  record: RelationshipRecord | undefined;
}

export interface ValidatePolicyRequest {
  policy: string;
  marshalType: PolicyMarshalingType;
}

export interface ValidatePolicyResponse {
  valid: boolean;
  errorMsg: string;
}

export interface SetParamsRequest {
  params: Params | undefined;
}

export interface SetParamsResponse {
}

export interface GetParamsRequest {
}

export interface GetParamsResponse {
  params: Params | undefined;
}

export interface VerifyAccessRequestRequest {
  policyId: string;
  accessRequest: AccessRequest | undefined;
}

export interface VerifyAccessRequestResponse {
  valid: boolean;
}

export interface GetPolicyCatalogueRequest {
  policyId: string;
}

export interface GetPolicyCatalogueResponse {
  catalogue: PolicyCatalogue | undefined;
}

export interface EvaluateTheoremRequest {
  /** policy_id is the id of the policy against which the theorem is evaluated */
  policyId: string;
  /** policy_theorem defines a PolicyTheorem using the DSL specified in the theorem grammar */
  policyTheorem: string;
}

export interface EvaluateTheoremResponse {
  /** result of theorem verification */
  result: AnnotatedPolicyTheoremResult | undefined;
}

export interface AmendRegistrationRequest {
  policyId: string;
  object: Object | undefined;
  newOwner: Actor | undefined;
}

export interface AmendRegistrationResponse {
  record: RelationshipRecord | undefined;
}

export interface UnarchiveObjectRequest {
  policyId: string;
  object: Object | undefined;
}

export interface UnarchiveObjectResponse {
  record: RelationshipRecord | undefined;
  recordModified: boolean;
}

function createBaseCreatePolicyRequest(): CreatePolicyRequest {
  return { policy: "", marshalType: 0, attributes: {} };
}

export const CreatePolicyRequest: MessageFns<CreatePolicyRequest> = {
  encode(message: CreatePolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== "") {
      writer.uint32(10).string(message.policy);
    }
    if (message.marshalType !== 0) {
      writer.uint32(16).int32(message.marshalType);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      CreatePolicyRequest_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policy = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.marshalType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = CreatePolicyRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePolicyRequest {
    return {
      policy: isSet(object.policy) ? globalThis.String(object.policy) : "",
      marshalType: isSet(object.marshalType) ? policyMarshalingTypeFromJSON(object.marshalType) : 0,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreatePolicyRequest): unknown {
    const obj: any = {};
    if (message.policy !== "") {
      obj.policy = message.policy;
    }
    if (message.marshalType !== 0) {
      obj.marshalType = policyMarshalingTypeToJSON(message.marshalType);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePolicyRequest>, I>>(base?: I): CreatePolicyRequest {
    return CreatePolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePolicyRequest>, I>>(object: I): CreatePolicyRequest {
    const message = createBaseCreatePolicyRequest();
    message.policy = object.policy ?? "";
    message.marshalType = object.marshalType ?? 0;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePolicyRequest_AttributesEntry(): CreatePolicyRequest_AttributesEntry {
  return { key: "", value: "" };
}

export const CreatePolicyRequest_AttributesEntry: MessageFns<CreatePolicyRequest_AttributesEntry> = {
  encode(message: CreatePolicyRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePolicyRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePolicyRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePolicyRequest_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePolicyRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePolicyRequest_AttributesEntry>, I>>(
    base?: I,
  ): CreatePolicyRequest_AttributesEntry {
    return CreatePolicyRequest_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePolicyRequest_AttributesEntry>, I>>(
    object: I,
  ): CreatePolicyRequest_AttributesEntry {
    const message = createBaseCreatePolicyRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreatePolicyResponse(): CreatePolicyResponse {
  return { policy: undefined, attributes: {} };
}

export const CreatePolicyResponse: MessageFns<CreatePolicyResponse> = {
  encode(message: CreatePolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      CreatePolicyResponse_AttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = CreatePolicyResponse_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePolicyResponse {
    return {
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreatePolicyResponse): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePolicyResponse>, I>>(base?: I): CreatePolicyResponse {
    return CreatePolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePolicyResponse>, I>>(object: I): CreatePolicyResponse {
    const message = createBaseCreatePolicyResponse();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePolicyResponse_AttributesEntry(): CreatePolicyResponse_AttributesEntry {
  return { key: "", value: "" };
}

export const CreatePolicyResponse_AttributesEntry: MessageFns<CreatePolicyResponse_AttributesEntry> = {
  encode(message: CreatePolicyResponse_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePolicyResponse_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePolicyResponse_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePolicyResponse_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePolicyResponse_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePolicyResponse_AttributesEntry>, I>>(
    base?: I,
  ): CreatePolicyResponse_AttributesEntry {
    return CreatePolicyResponse_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePolicyResponse_AttributesEntry>, I>>(
    object: I,
  ): CreatePolicyResponse_AttributesEntry {
    const message = createBaseCreatePolicyResponse_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetRelationshipRequest(): SetRelationshipRequest {
  return { policyId: "", relationship: undefined, attributes: {} };
}

export const SetRelationshipRequest: MessageFns<SetRelationshipRequest> = {
  encode(message: SetRelationshipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.relationship !== undefined) {
      Relationship.encode(message.relationship, writer.uint32(18).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      SetRelationshipRequest_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetRelationshipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRelationshipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationship = Relationship.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SetRelationshipRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetRelationshipRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      relationship: isSet(object.relationship) ? Relationship.fromJSON(object.relationship) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SetRelationshipRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.relationship !== undefined) {
      obj.relationship = Relationship.toJSON(message.relationship);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRelationshipRequest>, I>>(base?: I): SetRelationshipRequest {
    return SetRelationshipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRelationshipRequest>, I>>(object: I): SetRelationshipRequest {
    const message = createBaseSetRelationshipRequest();
    message.policyId = object.policyId ?? "";
    message.relationship = (object.relationship !== undefined && object.relationship !== null)
      ? Relationship.fromPartial(object.relationship)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSetRelationshipRequest_AttributesEntry(): SetRelationshipRequest_AttributesEntry {
  return { key: "", value: "" };
}

export const SetRelationshipRequest_AttributesEntry: MessageFns<SetRelationshipRequest_AttributesEntry> = {
  encode(message: SetRelationshipRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetRelationshipRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRelationshipRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetRelationshipRequest_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetRelationshipRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRelationshipRequest_AttributesEntry>, I>>(
    base?: I,
  ): SetRelationshipRequest_AttributesEntry {
    return SetRelationshipRequest_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRelationshipRequest_AttributesEntry>, I>>(
    object: I,
  ): SetRelationshipRequest_AttributesEntry {
    const message = createBaseSetRelationshipRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetRelationshipResponse(): SetRelationshipResponse {
  return { recordExisted: false, record: undefined };
}

export const SetRelationshipResponse: MessageFns<SetRelationshipResponse> = {
  encode(message: SetRelationshipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordExisted !== false) {
      writer.uint32(8).bool(message.recordExisted);
    }
    if (message.record !== undefined) {
      RelationshipRecord.encode(message.record, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetRelationshipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRelationshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recordExisted = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.record = RelationshipRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetRelationshipResponse {
    return {
      recordExisted: isSet(object.recordExisted) ? globalThis.Boolean(object.recordExisted) : false,
      record: isSet(object.record) ? RelationshipRecord.fromJSON(object.record) : undefined,
    };
  },

  toJSON(message: SetRelationshipResponse): unknown {
    const obj: any = {};
    if (message.recordExisted !== false) {
      obj.recordExisted = message.recordExisted;
    }
    if (message.record !== undefined) {
      obj.record = RelationshipRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetRelationshipResponse>, I>>(base?: I): SetRelationshipResponse {
    return SetRelationshipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetRelationshipResponse>, I>>(object: I): SetRelationshipResponse {
    const message = createBaseSetRelationshipResponse();
    message.recordExisted = object.recordExisted ?? false;
    message.record = (object.record !== undefined && object.record !== null)
      ? RelationshipRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseDeleteRelationshipRequest(): DeleteRelationshipRequest {
  return { policyId: "", relationship: undefined };
}

export const DeleteRelationshipRequest: MessageFns<DeleteRelationshipRequest> = {
  encode(message: DeleteRelationshipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.relationship !== undefined) {
      Relationship.encode(message.relationship, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRelationshipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRelationshipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationship = Relationship.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRelationshipRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      relationship: isSet(object.relationship) ? Relationship.fromJSON(object.relationship) : undefined,
    };
  },

  toJSON(message: DeleteRelationshipRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.relationship !== undefined) {
      obj.relationship = Relationship.toJSON(message.relationship);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRelationshipRequest>, I>>(base?: I): DeleteRelationshipRequest {
    return DeleteRelationshipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRelationshipRequest>, I>>(object: I): DeleteRelationshipRequest {
    const message = createBaseDeleteRelationshipRequest();
    message.policyId = object.policyId ?? "";
    message.relationship = (object.relationship !== undefined && object.relationship !== null)
      ? Relationship.fromPartial(object.relationship)
      : undefined;
    return message;
  },
};

function createBaseDeleteRelationshipResponse(): DeleteRelationshipResponse {
  return { recordFound: false };
}

export const DeleteRelationshipResponse: MessageFns<DeleteRelationshipResponse> = {
  encode(message: DeleteRelationshipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordFound !== false) {
      writer.uint32(8).bool(message.recordFound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRelationshipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRelationshipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recordFound = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRelationshipResponse {
    return { recordFound: isSet(object.recordFound) ? globalThis.Boolean(object.recordFound) : false };
  },

  toJSON(message: DeleteRelationshipResponse): unknown {
    const obj: any = {};
    if (message.recordFound !== false) {
      obj.recordFound = message.recordFound;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRelationshipResponse>, I>>(base?: I): DeleteRelationshipResponse {
    return DeleteRelationshipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRelationshipResponse>, I>>(object: I): DeleteRelationshipResponse {
    const message = createBaseDeleteRelationshipResponse();
    message.recordFound = object.recordFound ?? false;
    return message;
  },
};

function createBaseRegisterObjectRequest(): RegisterObjectRequest {
  return { policyId: "", object: undefined, attributes: {} };
}

export const RegisterObjectRequest: MessageFns<RegisterObjectRequest> = {
  encode(message: RegisterObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(18).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      RegisterObjectRequest_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = RegisterObjectRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterObjectRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RegisterObjectRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterObjectRequest>, I>>(base?: I): RegisterObjectRequest {
    return RegisterObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterObjectRequest>, I>>(object: I): RegisterObjectRequest {
    const message = createBaseRegisterObjectRequest();
    message.policyId = object.policyId ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRegisterObjectRequest_AttributesEntry(): RegisterObjectRequest_AttributesEntry {
  return { key: "", value: "" };
}

export const RegisterObjectRequest_AttributesEntry: MessageFns<RegisterObjectRequest_AttributesEntry> = {
  encode(message: RegisterObjectRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterObjectRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterObjectRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterObjectRequest_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RegisterObjectRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterObjectRequest_AttributesEntry>, I>>(
    base?: I,
  ): RegisterObjectRequest_AttributesEntry {
    return RegisterObjectRequest_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterObjectRequest_AttributesEntry>, I>>(
    object: I,
  ): RegisterObjectRequest_AttributesEntry {
    const message = createBaseRegisterObjectRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRegisterObjectResponse(): RegisterObjectResponse {
  return { record: undefined };
}

export const RegisterObjectResponse: MessageFns<RegisterObjectResponse> = {
  encode(message: RegisterObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== undefined) {
      RelationshipRecord.encode(message.record, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record = RelationshipRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterObjectResponse {
    return { record: isSet(object.record) ? RelationshipRecord.fromJSON(object.record) : undefined };
  },

  toJSON(message: RegisterObjectResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = RelationshipRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterObjectResponse>, I>>(base?: I): RegisterObjectResponse {
    return RegisterObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterObjectResponse>, I>>(object: I): RegisterObjectResponse {
    const message = createBaseRegisterObjectResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? RelationshipRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseArchiveObjectRequest(): ArchiveObjectRequest {
  return { policyId: "", object: undefined };
}

export const ArchiveObjectRequest: MessageFns<ArchiveObjectRequest> = {
  encode(message: ArchiveObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArchiveObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArchiveObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArchiveObjectRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
    };
  },

  toJSON(message: ArchiveObjectRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArchiveObjectRequest>, I>>(base?: I): ArchiveObjectRequest {
    return ArchiveObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArchiveObjectRequest>, I>>(object: I): ArchiveObjectRequest {
    const message = createBaseArchiveObjectRequest();
    message.policyId = object.policyId ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    return message;
  },
};

function createBaseArchiveObjectResponse(): ArchiveObjectResponse {
  return { relationshipsRemoved: 0, recordModified: false };
}

export const ArchiveObjectResponse: MessageFns<ArchiveObjectResponse> = {
  encode(message: ArchiveObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.relationshipsRemoved !== 0) {
      writer.uint32(8).uint64(message.relationshipsRemoved);
    }
    if (message.recordModified !== false) {
      writer.uint32(16).bool(message.recordModified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArchiveObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArchiveObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.relationshipsRemoved = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.recordModified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArchiveObjectResponse {
    return {
      relationshipsRemoved: isSet(object.relationshipsRemoved) ? globalThis.Number(object.relationshipsRemoved) : 0,
      recordModified: isSet(object.recordModified) ? globalThis.Boolean(object.recordModified) : false,
    };
  },

  toJSON(message: ArchiveObjectResponse): unknown {
    const obj: any = {};
    if (message.relationshipsRemoved !== 0) {
      obj.relationshipsRemoved = Math.round(message.relationshipsRemoved);
    }
    if (message.recordModified !== false) {
      obj.recordModified = message.recordModified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArchiveObjectResponse>, I>>(base?: I): ArchiveObjectResponse {
    return ArchiveObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArchiveObjectResponse>, I>>(object: I): ArchiveObjectResponse {
    const message = createBaseArchiveObjectResponse();
    message.relationshipsRemoved = object.relationshipsRemoved ?? 0;
    message.recordModified = object.recordModified ?? false;
    return message;
  },
};

function createBaseGetObjectRegistrationRequest(): GetObjectRegistrationRequest {
  return { policyId: "", object: undefined };
}

export const GetObjectRegistrationRequest: MessageFns<GetObjectRegistrationRequest> = {
  encode(message: GetObjectRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetObjectRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetObjectRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetObjectRegistrationRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
    };
  },

  toJSON(message: GetObjectRegistrationRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetObjectRegistrationRequest>, I>>(base?: I): GetObjectRegistrationRequest {
    return GetObjectRegistrationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetObjectRegistrationRequest>, I>>(object: I): GetObjectRegistrationRequest {
    const message = createBaseGetObjectRegistrationRequest();
    message.policyId = object.policyId ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    return message;
  },
};

function createBaseGetObjectRegistrationResponse(): GetObjectRegistrationResponse {
  return { isRegistered: false, ownerId: "", record: undefined };
}

export const GetObjectRegistrationResponse: MessageFns<GetObjectRegistrationResponse> = {
  encode(message: GetObjectRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isRegistered !== false) {
      writer.uint32(8).bool(message.isRegistered);
    }
    if (message.ownerId !== "") {
      writer.uint32(18).string(message.ownerId);
    }
    if (message.record !== undefined) {
      RelationshipRecord.encode(message.record, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetObjectRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetObjectRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isRegistered = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.record = RelationshipRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetObjectRegistrationResponse {
    return {
      isRegistered: isSet(object.isRegistered) ? globalThis.Boolean(object.isRegistered) : false,
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      record: isSet(object.record) ? RelationshipRecord.fromJSON(object.record) : undefined,
    };
  },

  toJSON(message: GetObjectRegistrationResponse): unknown {
    const obj: any = {};
    if (message.isRegistered !== false) {
      obj.isRegistered = message.isRegistered;
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.record !== undefined) {
      obj.record = RelationshipRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetObjectRegistrationResponse>, I>>(base?: I): GetObjectRegistrationResponse {
    return GetObjectRegistrationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetObjectRegistrationResponse>, I>>(
    object: I,
  ): GetObjectRegistrationResponse {
    const message = createBaseGetObjectRegistrationResponse();
    message.isRegistered = object.isRegistered ?? false;
    message.ownerId = object.ownerId ?? "";
    message.record = (object.record !== undefined && object.record !== null)
      ? RelationshipRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseFilterRelationshipsRequest(): FilterRelationshipsRequest {
  return { policyId: "", selector: undefined };
}

export const FilterRelationshipsRequest: MessageFns<FilterRelationshipsRequest> = {
  encode(message: FilterRelationshipsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.selector !== undefined) {
      RelationshipSelector.encode(message.selector, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterRelationshipsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterRelationshipsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.selector = RelationshipSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterRelationshipsRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      selector: isSet(object.selector) ? RelationshipSelector.fromJSON(object.selector) : undefined,
    };
  },

  toJSON(message: FilterRelationshipsRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.selector !== undefined) {
      obj.selector = RelationshipSelector.toJSON(message.selector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterRelationshipsRequest>, I>>(base?: I): FilterRelationshipsRequest {
    return FilterRelationshipsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterRelationshipsRequest>, I>>(object: I): FilterRelationshipsRequest {
    const message = createBaseFilterRelationshipsRequest();
    message.policyId = object.policyId ?? "";
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? RelationshipSelector.fromPartial(object.selector)
      : undefined;
    return message;
  },
};

function createBaseFilterRelationshipsResponse(): FilterRelationshipsResponse {
  return { records: [] };
}

export const FilterRelationshipsResponse: MessageFns<FilterRelationshipsResponse> = {
  encode(message: FilterRelationshipsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.records) {
      RelationshipRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterRelationshipsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterRelationshipsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.records.push(RelationshipRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterRelationshipsResponse {
    return {
      records: globalThis.Array.isArray(object?.records)
        ? object.records.map((e: any) => RelationshipRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FilterRelationshipsResponse): unknown {
    const obj: any = {};
    if (message.records?.length) {
      obj.records = message.records.map((e) => RelationshipRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterRelationshipsResponse>, I>>(base?: I): FilterRelationshipsResponse {
    return FilterRelationshipsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterRelationshipsResponse>, I>>(object: I): FilterRelationshipsResponse {
    const message = createBaseFilterRelationshipsResponse();
    message.records = object.records?.map((e) => RelationshipRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPolicyRequest(): GetPolicyRequest {
  return { id: "" };
}

export const GetPolicyRequest: MessageFns<GetPolicyRequest> = {
  encode(message: GetPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPolicyRequest>, I>>(base?: I): GetPolicyRequest {
    return GetPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPolicyRequest>, I>>(object: I): GetPolicyRequest {
    const message = createBaseGetPolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetPolicyResponse(): GetPolicyResponse {
  return { policy: undefined, policyRaw: "", marshalType: 0 };
}

export const GetPolicyResponse: MessageFns<GetPolicyResponse> = {
  encode(message: GetPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    if (message.policyRaw !== "") {
      writer.uint32(18).string(message.policyRaw);
    }
    if (message.marshalType !== 0) {
      writer.uint32(24).int32(message.marshalType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policyRaw = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.marshalType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPolicyResponse {
    return {
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      policyRaw: isSet(object.policyRaw) ? globalThis.String(object.policyRaw) : "",
      marshalType: isSet(object.marshalType) ? policyMarshalingTypeFromJSON(object.marshalType) : 0,
    };
  },

  toJSON(message: GetPolicyResponse): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.policyRaw !== "") {
      obj.policyRaw = message.policyRaw;
    }
    if (message.marshalType !== 0) {
      obj.marshalType = policyMarshalingTypeToJSON(message.marshalType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPolicyResponse>, I>>(base?: I): GetPolicyResponse {
    return GetPolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPolicyResponse>, I>>(object: I): GetPolicyResponse {
    const message = createBaseGetPolicyResponse();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.policyRaw = object.policyRaw ?? "";
    message.marshalType = object.marshalType ?? 0;
    return message;
  },
};

function createBaseListPoliciesRequest(): ListPoliciesRequest {
  return {};
}

export const ListPoliciesRequest: MessageFns<ListPoliciesRequest> = {
  encode(_: ListPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListPoliciesRequest {
    return {};
  },

  toJSON(_: ListPoliciesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPoliciesRequest>, I>>(base?: I): ListPoliciesRequest {
    return ListPoliciesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPoliciesRequest>, I>>(_: I): ListPoliciesRequest {
    const message = createBaseListPoliciesRequest();
    return message;
  },
};

function createBaseListPoliciesResponse(): ListPoliciesResponse {
  return { policies: [] };
}

export const ListPoliciesResponse: MessageFns<ListPoliciesResponse> = {
  encode(message: ListPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      Policy.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policies.push(Policy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPoliciesResponse {
    return {
      policies: globalThis.Array.isArray(object?.policies) ? object.policies.map((e: any) => Policy.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListPoliciesResponse): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => Policy.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPoliciesResponse>, I>>(base?: I): ListPoliciesResponse {
    return ListPoliciesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPoliciesResponse>, I>>(object: I): ListPoliciesResponse {
    const message = createBaseListPoliciesResponse();
    message.policies = object.policies?.map((e) => Policy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeletePolicyRequest(): DeletePolicyRequest {
  return { id: "" };
}

export const DeletePolicyRequest: MessageFns<DeletePolicyRequest> = {
  encode(message: DeletePolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeletePolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePolicyRequest>, I>>(base?: I): DeletePolicyRequest {
    return DeletePolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePolicyRequest>, I>>(object: I): DeletePolicyRequest {
    const message = createBaseDeletePolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeletePolicyResponse(): DeletePolicyResponse {
  return { found: false };
}

export const DeletePolicyResponse: MessageFns<DeletePolicyResponse> = {
  encode(message: DeletePolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePolicyResponse {
    return { found: isSet(object.found) ? globalThis.Boolean(object.found) : false };
  },

  toJSON(message: DeletePolicyResponse): unknown {
    const obj: any = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePolicyResponse>, I>>(base?: I): DeletePolicyResponse {
    return DeletePolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePolicyResponse>, I>>(object: I): DeletePolicyResponse {
    const message = createBaseDeletePolicyResponse();
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseTransferObjectRequest(): TransferObjectRequest {
  return { policyId: "", object: undefined, newOwner: undefined };
}

export const TransferObjectRequest: MessageFns<TransferObjectRequest> = {
  encode(message: TransferObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(18).fork()).join();
    }
    if (message.newOwner !== undefined) {
      Actor.encode(message.newOwner, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newOwner = Actor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferObjectRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
      newOwner: isSet(object.newOwner) ? Actor.fromJSON(object.newOwner) : undefined,
    };
  },

  toJSON(message: TransferObjectRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    if (message.newOwner !== undefined) {
      obj.newOwner = Actor.toJSON(message.newOwner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferObjectRequest>, I>>(base?: I): TransferObjectRequest {
    return TransferObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferObjectRequest>, I>>(object: I): TransferObjectRequest {
    const message = createBaseTransferObjectRequest();
    message.policyId = object.policyId ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    message.newOwner = (object.newOwner !== undefined && object.newOwner !== null)
      ? Actor.fromPartial(object.newOwner)
      : undefined;
    return message;
  },
};

function createBaseTransferObjectResponse(): TransferObjectResponse {
  return { record: undefined };
}

export const TransferObjectResponse: MessageFns<TransferObjectResponse> = {
  encode(message: TransferObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== undefined) {
      RelationshipRecord.encode(message.record, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record = RelationshipRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferObjectResponse {
    return { record: isSet(object.record) ? RelationshipRecord.fromJSON(object.record) : undefined };
  },

  toJSON(message: TransferObjectResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = RelationshipRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferObjectResponse>, I>>(base?: I): TransferObjectResponse {
    return TransferObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferObjectResponse>, I>>(object: I): TransferObjectResponse {
    const message = createBaseTransferObjectResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? RelationshipRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseValidatePolicyRequest(): ValidatePolicyRequest {
  return { policy: "", marshalType: 0 };
}

export const ValidatePolicyRequest: MessageFns<ValidatePolicyRequest> = {
  encode(message: ValidatePolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== "") {
      writer.uint32(10).string(message.policy);
    }
    if (message.marshalType !== 0) {
      writer.uint32(16).int32(message.marshalType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policy = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.marshalType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatePolicyRequest {
    return {
      policy: isSet(object.policy) ? globalThis.String(object.policy) : "",
      marshalType: isSet(object.marshalType) ? policyMarshalingTypeFromJSON(object.marshalType) : 0,
    };
  },

  toJSON(message: ValidatePolicyRequest): unknown {
    const obj: any = {};
    if (message.policy !== "") {
      obj.policy = message.policy;
    }
    if (message.marshalType !== 0) {
      obj.marshalType = policyMarshalingTypeToJSON(message.marshalType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatePolicyRequest>, I>>(base?: I): ValidatePolicyRequest {
    return ValidatePolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatePolicyRequest>, I>>(object: I): ValidatePolicyRequest {
    const message = createBaseValidatePolicyRequest();
    message.policy = object.policy ?? "";
    message.marshalType = object.marshalType ?? 0;
    return message;
  },
};

function createBaseValidatePolicyResponse(): ValidatePolicyResponse {
  return { valid: false, errorMsg: "" };
}

export const ValidatePolicyResponse: MessageFns<ValidatePolicyResponse> = {
  encode(message: ValidatePolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.errorMsg !== "") {
      writer.uint32(18).string(message.errorMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMsg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatePolicyResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      errorMsg: isSet(object.errorMsg) ? globalThis.String(object.errorMsg) : "",
    };
  },

  toJSON(message: ValidatePolicyResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.errorMsg !== "") {
      obj.errorMsg = message.errorMsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatePolicyResponse>, I>>(base?: I): ValidatePolicyResponse {
    return ValidatePolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatePolicyResponse>, I>>(object: I): ValidatePolicyResponse {
    const message = createBaseValidatePolicyResponse();
    message.valid = object.valid ?? false;
    message.errorMsg = object.errorMsg ?? "";
    return message;
  },
};

function createBaseSetParamsRequest(): SetParamsRequest {
  return { params: undefined };
}

export const SetParamsRequest: MessageFns<SetParamsRequest> = {
  encode(message: SetParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetParamsRequest {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: SetParamsRequest): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetParamsRequest>, I>>(base?: I): SetParamsRequest {
    return SetParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetParamsRequest>, I>>(object: I): SetParamsRequest {
    const message = createBaseSetParamsRequest();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseSetParamsResponse(): SetParamsResponse {
  return {};
}

export const SetParamsResponse: MessageFns<SetParamsResponse> = {
  encode(_: SetParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetParamsResponse {
    return {};
  },

  toJSON(_: SetParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetParamsResponse>, I>>(base?: I): SetParamsResponse {
    return SetParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetParamsResponse>, I>>(_: I): SetParamsResponse {
    const message = createBaseSetParamsResponse();
    return message;
  },
};

function createBaseGetParamsRequest(): GetParamsRequest {
  return {};
}

export const GetParamsRequest: MessageFns<GetParamsRequest> = {
  encode(_: GetParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetParamsRequest {
    return {};
  },

  toJSON(_: GetParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParamsRequest>, I>>(base?: I): GetParamsRequest {
    return GetParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParamsRequest>, I>>(_: I): GetParamsRequest {
    const message = createBaseGetParamsRequest();
    return message;
  },
};

function createBaseGetParamsResponse(): GetParamsResponse {
  return { params: undefined };
}

export const GetParamsResponse: MessageFns<GetParamsResponse> = {
  encode(message: GetParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: GetParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParamsResponse>, I>>(base?: I): GetParamsResponse {
    return GetParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParamsResponse>, I>>(object: I): GetParamsResponse {
    const message = createBaseGetParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseVerifyAccessRequestRequest(): VerifyAccessRequestRequest {
  return { policyId: "", accessRequest: undefined };
}

export const VerifyAccessRequestRequest: MessageFns<VerifyAccessRequestRequest> = {
  encode(message: VerifyAccessRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.accessRequest !== undefined) {
      AccessRequest.encode(message.accessRequest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccessRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccessRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessRequest = AccessRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccessRequestRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      accessRequest: isSet(object.accessRequest) ? AccessRequest.fromJSON(object.accessRequest) : undefined,
    };
  },

  toJSON(message: VerifyAccessRequestRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.accessRequest !== undefined) {
      obj.accessRequest = AccessRequest.toJSON(message.accessRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccessRequestRequest>, I>>(base?: I): VerifyAccessRequestRequest {
    return VerifyAccessRequestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccessRequestRequest>, I>>(object: I): VerifyAccessRequestRequest {
    const message = createBaseVerifyAccessRequestRequest();
    message.policyId = object.policyId ?? "";
    message.accessRequest = (object.accessRequest !== undefined && object.accessRequest !== null)
      ? AccessRequest.fromPartial(object.accessRequest)
      : undefined;
    return message;
  },
};

function createBaseVerifyAccessRequestResponse(): VerifyAccessRequestResponse {
  return { valid: false };
}

export const VerifyAccessRequestResponse: MessageFns<VerifyAccessRequestResponse> = {
  encode(message: VerifyAccessRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccessRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccessRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccessRequestResponse {
    return { valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false };
  },

  toJSON(message: VerifyAccessRequestResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccessRequestResponse>, I>>(base?: I): VerifyAccessRequestResponse {
    return VerifyAccessRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccessRequestResponse>, I>>(object: I): VerifyAccessRequestResponse {
    const message = createBaseVerifyAccessRequestResponse();
    message.valid = object.valid ?? false;
    return message;
  },
};

function createBaseGetPolicyCatalogueRequest(): GetPolicyCatalogueRequest {
  return { policyId: "" };
}

export const GetPolicyCatalogueRequest: MessageFns<GetPolicyCatalogueRequest> = {
  encode(message: GetPolicyCatalogueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPolicyCatalogueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyCatalogueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPolicyCatalogueRequest {
    return { policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "" };
  },

  toJSON(message: GetPolicyCatalogueRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPolicyCatalogueRequest>, I>>(base?: I): GetPolicyCatalogueRequest {
    return GetPolicyCatalogueRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPolicyCatalogueRequest>, I>>(object: I): GetPolicyCatalogueRequest {
    const message = createBaseGetPolicyCatalogueRequest();
    message.policyId = object.policyId ?? "";
    return message;
  },
};

function createBaseGetPolicyCatalogueResponse(): GetPolicyCatalogueResponse {
  return { catalogue: undefined };
}

export const GetPolicyCatalogueResponse: MessageFns<GetPolicyCatalogueResponse> = {
  encode(message: GetPolicyCatalogueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.catalogue !== undefined) {
      PolicyCatalogue.encode(message.catalogue, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPolicyCatalogueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyCatalogueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.catalogue = PolicyCatalogue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPolicyCatalogueResponse {
    return { catalogue: isSet(object.catalogue) ? PolicyCatalogue.fromJSON(object.catalogue) : undefined };
  },

  toJSON(message: GetPolicyCatalogueResponse): unknown {
    const obj: any = {};
    if (message.catalogue !== undefined) {
      obj.catalogue = PolicyCatalogue.toJSON(message.catalogue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPolicyCatalogueResponse>, I>>(base?: I): GetPolicyCatalogueResponse {
    return GetPolicyCatalogueResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPolicyCatalogueResponse>, I>>(object: I): GetPolicyCatalogueResponse {
    const message = createBaseGetPolicyCatalogueResponse();
    message.catalogue = (object.catalogue !== undefined && object.catalogue !== null)
      ? PolicyCatalogue.fromPartial(object.catalogue)
      : undefined;
    return message;
  },
};

function createBaseEvaluateTheoremRequest(): EvaluateTheoremRequest {
  return { policyId: "", policyTheorem: "" };
}

export const EvaluateTheoremRequest: MessageFns<EvaluateTheoremRequest> = {
  encode(message: EvaluateTheoremRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.policyTheorem !== "") {
      writer.uint32(18).string(message.policyTheorem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateTheoremRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateTheoremRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policyTheorem = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateTheoremRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      policyTheorem: isSet(object.policyTheorem) ? globalThis.String(object.policyTheorem) : "",
    };
  },

  toJSON(message: EvaluateTheoremRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.policyTheorem !== "") {
      obj.policyTheorem = message.policyTheorem;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluateTheoremRequest>, I>>(base?: I): EvaluateTheoremRequest {
    return EvaluateTheoremRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluateTheoremRequest>, I>>(object: I): EvaluateTheoremRequest {
    const message = createBaseEvaluateTheoremRequest();
    message.policyId = object.policyId ?? "";
    message.policyTheorem = object.policyTheorem ?? "";
    return message;
  },
};

function createBaseEvaluateTheoremResponse(): EvaluateTheoremResponse {
  return { result: undefined };
}

export const EvaluateTheoremResponse: MessageFns<EvaluateTheoremResponse> = {
  encode(message: EvaluateTheoremResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      AnnotatedPolicyTheoremResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateTheoremResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateTheoremResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = AnnotatedPolicyTheoremResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateTheoremResponse {
    return { result: isSet(object.result) ? AnnotatedPolicyTheoremResult.fromJSON(object.result) : undefined };
  },

  toJSON(message: EvaluateTheoremResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = AnnotatedPolicyTheoremResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluateTheoremResponse>, I>>(base?: I): EvaluateTheoremResponse {
    return EvaluateTheoremResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluateTheoremResponse>, I>>(object: I): EvaluateTheoremResponse {
    const message = createBaseEvaluateTheoremResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? AnnotatedPolicyTheoremResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseAmendRegistrationRequest(): AmendRegistrationRequest {
  return { policyId: "", object: undefined, newOwner: undefined };
}

export const AmendRegistrationRequest: MessageFns<AmendRegistrationRequest> = {
  encode(message: AmendRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(18).fork()).join();
    }
    if (message.newOwner !== undefined) {
      Actor.encode(message.newOwner, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AmendRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmendRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newOwner = Actor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AmendRegistrationRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
      newOwner: isSet(object.newOwner) ? Actor.fromJSON(object.newOwner) : undefined,
    };
  },

  toJSON(message: AmendRegistrationRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    if (message.newOwner !== undefined) {
      obj.newOwner = Actor.toJSON(message.newOwner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AmendRegistrationRequest>, I>>(base?: I): AmendRegistrationRequest {
    return AmendRegistrationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AmendRegistrationRequest>, I>>(object: I): AmendRegistrationRequest {
    const message = createBaseAmendRegistrationRequest();
    message.policyId = object.policyId ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    message.newOwner = (object.newOwner !== undefined && object.newOwner !== null)
      ? Actor.fromPartial(object.newOwner)
      : undefined;
    return message;
  },
};

function createBaseAmendRegistrationResponse(): AmendRegistrationResponse {
  return { record: undefined };
}

export const AmendRegistrationResponse: MessageFns<AmendRegistrationResponse> = {
  encode(message: AmendRegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== undefined) {
      RelationshipRecord.encode(message.record, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AmendRegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmendRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record = RelationshipRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AmendRegistrationResponse {
    return { record: isSet(object.record) ? RelationshipRecord.fromJSON(object.record) : undefined };
  },

  toJSON(message: AmendRegistrationResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = RelationshipRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AmendRegistrationResponse>, I>>(base?: I): AmendRegistrationResponse {
    return AmendRegistrationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AmendRegistrationResponse>, I>>(object: I): AmendRegistrationResponse {
    const message = createBaseAmendRegistrationResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? RelationshipRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseUnarchiveObjectRequest(): UnarchiveObjectRequest {
  return { policyId: "", object: undefined };
}

export const UnarchiveObjectRequest: MessageFns<UnarchiveObjectRequest> = {
  encode(message: UnarchiveObjectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyId !== "") {
      writer.uint32(10).string(message.policyId);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnarchiveObjectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnarchiveObjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnarchiveObjectRequest {
    return {
      policyId: isSet(object.policyId) ? globalThis.String(object.policyId) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
    };
  },

  toJSON(message: UnarchiveObjectRequest): unknown {
    const obj: any = {};
    if (message.policyId !== "") {
      obj.policyId = message.policyId;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnarchiveObjectRequest>, I>>(base?: I): UnarchiveObjectRequest {
    return UnarchiveObjectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnarchiveObjectRequest>, I>>(object: I): UnarchiveObjectRequest {
    const message = createBaseUnarchiveObjectRequest();
    message.policyId = object.policyId ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    return message;
  },
};

function createBaseUnarchiveObjectResponse(): UnarchiveObjectResponse {
  return { record: undefined, recordModified: false };
}

export const UnarchiveObjectResponse: MessageFns<UnarchiveObjectResponse> = {
  encode(message: UnarchiveObjectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== undefined) {
      RelationshipRecord.encode(message.record, writer.uint32(10).fork()).join();
    }
    if (message.recordModified !== false) {
      writer.uint32(16).bool(message.recordModified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnarchiveObjectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnarchiveObjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record = RelationshipRecord.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.recordModified = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnarchiveObjectResponse {
    return {
      record: isSet(object.record) ? RelationshipRecord.fromJSON(object.record) : undefined,
      recordModified: isSet(object.recordModified) ? globalThis.Boolean(object.recordModified) : false,
    };
  },

  toJSON(message: UnarchiveObjectResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = RelationshipRecord.toJSON(message.record);
    }
    if (message.recordModified !== false) {
      obj.recordModified = message.recordModified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnarchiveObjectResponse>, I>>(base?: I): UnarchiveObjectResponse {
    return UnarchiveObjectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnarchiveObjectResponse>, I>>(object: I): UnarchiveObjectResponse {
    const message = createBaseUnarchiveObjectResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? RelationshipRecord.fromPartial(object.record)
      : undefined;
    message.recordModified = object.recordModified ?? false;
    return message;
  },
};

export interface ACPEngine {
  /**
   * CreatePolicy adds a new Policy to SourceHub.
   * The Policy models an aplication's high level access control rules.
   */
  CreatePolicy(request: CreatePolicyRequest): Promise<CreatePolicyResponse>;
  /** GetPolicy returns a Policy with the given ID */
  GetPolicy(request: GetPolicyRequest): Promise<GetPolicyResponse>;
  /** GetPolicyCatalogue builds and return a Policy's Catalogue */
  GetPolicyCatalogue(request: GetPolicyCatalogueRequest): Promise<GetPolicyCatalogueResponse>;
  /** ListPolicies returns a set of Policies registered in the system */
  ListPolicies(request: ListPoliciesRequest): Promise<ListPoliciesResponse>;
  /** DeletePolicy removes a Policy and all relationships and objects registered within it. */
  DeletePolicy(request: DeletePolicyRequest): Promise<DeletePolicyResponse>;
  /**
   * SetRelationship creates or updates a Relationship within a Policy
   * A Relationship is a statement which ties together an object and a subject with a "relation",
   * which means the set of high level rules defined in the Policy will apply to these entities.
   */
  SetRelationship(request: SetRelationshipRequest): Promise<SetRelationshipResponse>;
  /**
   * DelereRelationship removes a Relationship from a Policy.
   * If the Relationship was not found in a Policy, this Cmd is a no-op.
   */
  DeleteRelationship(request: DeleteRelationshipRequest): Promise<DeleteRelationshipResponse>;
  /**
   * RegisterObject creates a special kind of Relationship within a Policy which ties
   * the msg's Actor as the owner of the msg's Object.
   * The Owner has complete control over the set of subjects that are related to their Object,
   * giving them autonomy to share the object and revoke acces to the object,
   * much like owners in a Discretionary Access Control model.
   *
   * Attempting to register a previously registered Object - whether active or archived -
   * is an error, Object IDs are therefore assumed to be unique within a Policy.
   */
  RegisterObject(request: RegisterObjectRequest): Promise<RegisterObjectResponse>;
  /**
   * ArchiveObject sets an Object's state as "archived"
   *
   * Archiving an object removes all relationships and effectively disables it.
   * No relationships can be created for it and no checks can be executed against it.
   * Note that the original owner record is preserved for security reasons.
   *
   * Attempting to archive an already archived object is a noop.
   * Archiving an object that isn't registered is an error
   * Only the owner can archive an object
   *
   * Note: ownership records aren't removed since doing so could lead to an ownership hijack attack.
   * In order to pass ownership to another owner, use the TransferObject method.
   *
   * Hijack attacks look like the following:
   * Suppose Bob owns object Foo, which is shared with Bob but not Eve.
   * Eve wants to access Foo but was not given permission to it.
   * Eve could "hijack" Bob's object by waiting for Bob to delete its ownership record for Foo,
   * then submitting a RegisterObject Cmd, effectively becoming Foo's new owner.
   * If Charlie has a copy of the object, Eve could convince Charlie to share his copy, granting Eve access to Foo.
   * The previous scenario where an unauthorized user is able to claim ownership to data previously unaccessible to them
   * is an "ownership hijack".
   */
  ArchiveObject(request: ArchiveObjectRequest): Promise<ArchiveObjectResponse>;
  /**
   * TransferObject updates an Object's Owner to some other actor in the system, after which the original owner
   * loses autonomy over the object and cannot create or modify relationships.
   *
   * Transfering object cannot be reversed, unless another Transfer is initiated by the new owner.
   *
   * Transfering an archived or unregistered object is an error.
   * Only the owner can transfer an object.
   */
  TransferObject(request: TransferObjectRequest): Promise<TransferObjectResponse>;
  /**
   * UnarchiveObject returns a previously archived object to active status,
   * such that the owner is able to create relationships and share that object again.
   *
   * Only the original owner of the object can unarchive it, returns an authorization error otherwise.
   * Attempting to unarchive an active or unregistered object is an error.
   */
  UnarchiveObject(request: UnarchiveObjectRequest): Promise<UnarchiveObjectResponse>;
  /**
   * AmendRegistration transfer an object's ownership between two users
   * This operation can only be executed by the root principal.
   *
   * Amending the registration of an archived or unregistered object is an error.
   */
  AmendRegistration(request: AmendRegistrationRequest): Promise<AmendRegistrationResponse>;
  /**
   * EvaluateTheorem executes the given theorem against a stored policy.
   *
   * Returns an error if the policy does not exist.
   */
  EvaluateTheorem(request: EvaluateTheoremRequest): Promise<EvaluateTheoremResponse>;
  /** GetObjectRegistration returns the registration status of an Object */
  GetObjectRegistration(request: GetObjectRegistrationRequest): Promise<GetObjectRegistrationResponse>;
  /** FilterRelationships returns filtered set of Relationships in a Policy. */
  FilterRelationships(request: FilterRelationshipsRequest): Promise<FilterRelationshipsResponse>;
  /**
   * ValidatePolicy verifies whether a policy payload is valid and would be accepted
   * by the engine, without creating it.
   *
   * Returns ok or validation errors found within the policy construction
   */
  ValidatePolicy(request: ValidatePolicyRequest): Promise<ValidatePolicyResponse>;
  /**
   * SetParams tunes the parameters of the ACP Engine.
   * This operation can only be done by the root principal
   */
  SetParams(request: SetParamsRequest): Promise<SetParamsResponse>;
  /** GetParams returns the current params set in the ACP Engine. */
  GetParams(request: GetParamsRequest): Promise<GetParamsResponse>;
  /**
   * VerifyAccessRequest evaluates an AccessRequest
   * Returns true if the authenticated actor is allowed to perform the operations they are requesting.
   * FIXME: there is no need to bind the authenticated principal to the AccessRequest,
   * the verification is often done by someone else
   */
  VerifyAccessRequest(request: VerifyAccessRequestRequest): Promise<VerifyAccessRequestResponse>;
}

export const ACPEngineServiceName = "sourcenetwork.acp_core.ACPEngine";
export class ACPEngineClientImpl implements ACPEngine {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ACPEngineServiceName;
    this.rpc = rpc;
    this.CreatePolicy = this.CreatePolicy.bind(this);
    this.GetPolicy = this.GetPolicy.bind(this);
    this.GetPolicyCatalogue = this.GetPolicyCatalogue.bind(this);
    this.ListPolicies = this.ListPolicies.bind(this);
    this.DeletePolicy = this.DeletePolicy.bind(this);
    this.SetRelationship = this.SetRelationship.bind(this);
    this.DeleteRelationship = this.DeleteRelationship.bind(this);
    this.RegisterObject = this.RegisterObject.bind(this);
    this.ArchiveObject = this.ArchiveObject.bind(this);
    this.TransferObject = this.TransferObject.bind(this);
    this.UnarchiveObject = this.UnarchiveObject.bind(this);
    this.AmendRegistration = this.AmendRegistration.bind(this);
    this.EvaluateTheorem = this.EvaluateTheorem.bind(this);
    this.GetObjectRegistration = this.GetObjectRegistration.bind(this);
    this.FilterRelationships = this.FilterRelationships.bind(this);
    this.ValidatePolicy = this.ValidatePolicy.bind(this);
    this.SetParams = this.SetParams.bind(this);
    this.GetParams = this.GetParams.bind(this);
    this.VerifyAccessRequest = this.VerifyAccessRequest.bind(this);
  }
  CreatePolicy(request: CreatePolicyRequest): Promise<CreatePolicyResponse> {
    const data = CreatePolicyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreatePolicy", data);
    return promise.then((data) => CreatePolicyResponse.decode(new BinaryReader(data)));
  }

  GetPolicy(request: GetPolicyRequest): Promise<GetPolicyResponse> {
    const data = GetPolicyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPolicy", data);
    return promise.then((data) => GetPolicyResponse.decode(new BinaryReader(data)));
  }

  GetPolicyCatalogue(request: GetPolicyCatalogueRequest): Promise<GetPolicyCatalogueResponse> {
    const data = GetPolicyCatalogueRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPolicyCatalogue", data);
    return promise.then((data) => GetPolicyCatalogueResponse.decode(new BinaryReader(data)));
  }

  ListPolicies(request: ListPoliciesRequest): Promise<ListPoliciesResponse> {
    const data = ListPoliciesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListPolicies", data);
    return promise.then((data) => ListPoliciesResponse.decode(new BinaryReader(data)));
  }

  DeletePolicy(request: DeletePolicyRequest): Promise<DeletePolicyResponse> {
    const data = DeletePolicyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeletePolicy", data);
    return promise.then((data) => DeletePolicyResponse.decode(new BinaryReader(data)));
  }

  SetRelationship(request: SetRelationshipRequest): Promise<SetRelationshipResponse> {
    const data = SetRelationshipRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetRelationship", data);
    return promise.then((data) => SetRelationshipResponse.decode(new BinaryReader(data)));
  }

  DeleteRelationship(request: DeleteRelationshipRequest): Promise<DeleteRelationshipResponse> {
    const data = DeleteRelationshipRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteRelationship", data);
    return promise.then((data) => DeleteRelationshipResponse.decode(new BinaryReader(data)));
  }

  RegisterObject(request: RegisterObjectRequest): Promise<RegisterObjectResponse> {
    const data = RegisterObjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterObject", data);
    return promise.then((data) => RegisterObjectResponse.decode(new BinaryReader(data)));
  }

  ArchiveObject(request: ArchiveObjectRequest): Promise<ArchiveObjectResponse> {
    const data = ArchiveObjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ArchiveObject", data);
    return promise.then((data) => ArchiveObjectResponse.decode(new BinaryReader(data)));
  }

  TransferObject(request: TransferObjectRequest): Promise<TransferObjectResponse> {
    const data = TransferObjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TransferObject", data);
    return promise.then((data) => TransferObjectResponse.decode(new BinaryReader(data)));
  }

  UnarchiveObject(request: UnarchiveObjectRequest): Promise<UnarchiveObjectResponse> {
    const data = UnarchiveObjectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnarchiveObject", data);
    return promise.then((data) => UnarchiveObjectResponse.decode(new BinaryReader(data)));
  }

  AmendRegistration(request: AmendRegistrationRequest): Promise<AmendRegistrationResponse> {
    const data = AmendRegistrationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AmendRegistration", data);
    return promise.then((data) => AmendRegistrationResponse.decode(new BinaryReader(data)));
  }

  EvaluateTheorem(request: EvaluateTheoremRequest): Promise<EvaluateTheoremResponse> {
    const data = EvaluateTheoremRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EvaluateTheorem", data);
    return promise.then((data) => EvaluateTheoremResponse.decode(new BinaryReader(data)));
  }

  GetObjectRegistration(request: GetObjectRegistrationRequest): Promise<GetObjectRegistrationResponse> {
    const data = GetObjectRegistrationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetObjectRegistration", data);
    return promise.then((data) => GetObjectRegistrationResponse.decode(new BinaryReader(data)));
  }

  FilterRelationships(request: FilterRelationshipsRequest): Promise<FilterRelationshipsResponse> {
    const data = FilterRelationshipsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FilterRelationships", data);
    return promise.then((data) => FilterRelationshipsResponse.decode(new BinaryReader(data)));
  }

  ValidatePolicy(request: ValidatePolicyRequest): Promise<ValidatePolicyResponse> {
    const data = ValidatePolicyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidatePolicy", data);
    return promise.then((data) => ValidatePolicyResponse.decode(new BinaryReader(data)));
  }

  SetParams(request: SetParamsRequest): Promise<SetParamsResponse> {
    const data = SetParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetParams", data);
    return promise.then((data) => SetParamsResponse.decode(new BinaryReader(data)));
  }

  GetParams(request: GetParamsRequest): Promise<GetParamsResponse> {
    const data = GetParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetParams", data);
    return promise.then((data) => GetParamsResponse.decode(new BinaryReader(data)));
  }

  VerifyAccessRequest(request: VerifyAccessRequestRequest): Promise<VerifyAccessRequestResponse> {
    const data = VerifyAccessRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VerifyAccessRequest", data);
    return promise.then((data) => VerifyAccessRequestResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
