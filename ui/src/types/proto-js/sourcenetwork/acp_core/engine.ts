// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: sourcenetwork/acp_core/engine.proto

/* eslint-disable */
import { type PolicyCatalogue } from "./catalogue";
import { type SuppliedMetadata } from "./metadata";
import { type PolicyRecord } from "./policy_record";
import { type PolicyMarshalingType } from "./policy_short";
import { type Actor, type Object, type Relationship, type RelationshipRecord } from "./relationship";
import { type RelationshipSelector } from "./relationship_selector";
import { type AccessRequest } from "./request";
import { type PolicySpecificationType } from "./specification";
import { type Params } from "./system";
import { type AnnotatedPolicyTheoremResult } from "./theorem";

export const protobufPackage = "sourcenetwork.acp_core";

export interface CreatePolicyRequest {
  policy: string;
  marshalType: PolicyMarshalingType;
  metadata: SuppliedMetadata | undefined;
}

export interface CreatePolicyResponse {
  record: PolicyRecord | undefined;
}

export interface CreatePolicyWithSpecificationRequest {
  policy: string;
  marshalType: PolicyMarshalingType;
  metadata:
    | SuppliedMetadata
    | undefined;
  /**
   * required_spec indicates the specification which the policy must satisfy
   * if the policy does not satisfy it or informs a different
   * spec, produces an error
   */
  requiredSpec: PolicySpecificationType;
}

export interface EditPolicyRequest {
  policyId: string;
  policy: string;
  marshalType: PolicyMarshalingType;
}

export interface EditPolicyResponse {
  record: PolicyRecord | undefined;
  relatinshipsRemoved: number;
}

export interface EditPolicyMetadataRequest {
  policyId: string;
  metadata: SuppliedMetadata | undefined;
}

export interface EditPolicyMetadataResponse {
  record: PolicyRecord | undefined;
}

export interface CreatePolicyWithSpecificationResponse {
  record: PolicyRecord | undefined;
}

export interface SetRelationshipRequest {
  policyId: string;
  relationship: Relationship | undefined;
  metadata: SuppliedMetadata | undefined;
}

export interface SetRelationshipResponse {
  /** Indicates whether the given Relationship previously existed, ie the Tx was a no op */
  recordExisted: boolean;
  record: RelationshipRecord | undefined;
}

export interface DeleteRelationshipRequest {
  policyId: string;
  relationship: Relationship | undefined;
}

export interface DeleteRelationshipResponse {
  recordFound: boolean;
}

export interface RegisterObjectRequest {
  policyId: string;
  object: Object | undefined;
  metadata: SuppliedMetadata | undefined;
}

export interface RegisterObjectResponse {
  record: RelationshipRecord | undefined;
}

export interface ArchiveObjectRequest {
  policyId: string;
  object: Object | undefined;
}

export interface ArchiveObjectResponse {
  relationshipsRemoved: number;
  recordModified: boolean;
}

export interface GetObjectRegistrationRequest {
  policyId: string;
  object: Object | undefined;
}

export interface GetObjectRegistrationResponse {
  isRegistered: boolean;
  ownerId: string;
  record: RelationshipRecord | undefined;
}

export interface FilterRelationshipsRequest {
  policyId: string;
  selector: RelationshipSelector | undefined;
}

export interface FilterRelationshipsResponse {
  records: RelationshipRecord[];
}

export interface GetPolicyRequest {
  /** id of the Policy to be fetched */
  id: string;
}

export interface GetPolicyResponse {
  record: PolicyRecord | undefined;
}

export interface ListPoliciesRequest {
}

export interface ListPoliciesResponse {
  records: PolicyRecord[];
}

export interface DeletePolicyRequest {
  id: string;
}

export interface DeletePolicyResponse {
  found: boolean;
}

export interface TransferObjectRequest {
  policyId: string;
  object: Object | undefined;
  newOwner: Actor | undefined;
}

export interface TransferObjectResponse {
  record: RelationshipRecord | undefined;
}

export interface ValidatePolicyRequest {
  policy: string;
  marshalType: PolicyMarshalingType;
}

export interface ValidatePolicyResponse {
  valid: boolean;
  errorMsg: string;
}

export interface SetParamsRequest {
  params: Params | undefined;
}

export interface SetParamsResponse {
  params: Params | undefined;
}

export interface GetParamsRequest {
}

export interface GetParamsResponse {
  params: Params | undefined;
}

export interface VerifyAccessRequestRequest {
  policyId: string;
  accessRequest: AccessRequest | undefined;
}

export interface VerifyAccessRequestResponse {
  valid: boolean;
}

export interface GetPolicyCatalogueRequest {
  policyId: string;
}

export interface GetPolicyCatalogueResponse {
  catalogue: PolicyCatalogue | undefined;
}

export interface EvaluateTheoremRequest {
  /** policy_id is the id of the policy against which the theorem is evaluated */
  policyId: string;
  /** policy_theorem defines a PolicyTheorem using the DSL specified in the theorem grammar */
  policyTheorem: string;
}

export interface EvaluateTheoremResponse {
  /** result of theorem verification */
  result: AnnotatedPolicyTheoremResult | undefined;
}

export interface AmendRegistrationRequest {
  policyId: string;
  object: Object | undefined;
  newOwner: Actor | undefined;
  newCreationTs: Date | undefined;
  metadata: SuppliedMetadata | undefined;
}

export interface AmendRegistrationResponse {
  record: RelationshipRecord | undefined;
}

export interface UnarchiveObjectRequest {
  policyId: string;
  object: Object | undefined;
}

export interface UnarchiveObjectResponse {
  record: RelationshipRecord | undefined;
  recordModified: boolean;
}

export interface RevealRegistrationRequest {
  policyId: string;
  object: Object | undefined;
  creationTs: Date | undefined;
  metadata: SuppliedMetadata | undefined;
}

export interface RevealRegistrationResponse {
  record: RelationshipRecord | undefined;
}

export interface ACPEngine {
  /**
   * CreatePolicy adds a new Policy to the engine.
   * The Policy models an aplication's high level access control rules.
   */
  CreatePolicy(request: CreatePolicyRequest): Promise<CreatePolicyResponse>;
  /**
   * CreatePolicyWithSpecificatoin adds a new Policy to engine,
   * which must satisfy the supplied specification.
   */
  CreatePolicyWithSpecification(
    request: CreatePolicyWithSpecificationRequest,
  ): Promise<CreatePolicyWithSpecificationResponse>;
  /**
   * EditPolicy updates a Policy definition bound to some Id.
   * The relations may be added and removed to resources (if they are not required),
   * new resources may be added, but resources may not be removed.
   *
   * Removing a relation removes all relationships that reference the removed relation
   *
   * A few other invariants are enforced such as:
   * - the name of the actor resource cannot be mutated
   * - resources cannot be removed
   * - the specification of a policy cannot be mutated
   */
  EditPolicy(request: EditPolicyRequest): Promise<EditPolicyResponse>;
  /** EditPolicyMetadata updates the supplied metadata attached to a Policy record */
  EditPolicyMetadata(request: EditPolicyMetadataRequest): Promise<EditPolicyMetadataResponse>;
  /** GetPolicy returns a Policy with the given ID */
  GetPolicy(request: GetPolicyRequest): Promise<GetPolicyResponse>;
  /** GetPolicyCatalogue builds and return a Policy's Catalogue */
  GetPolicyCatalogue(request: GetPolicyCatalogueRequest): Promise<GetPolicyCatalogueResponse>;
  /** ListPolicies returns a set of Policies registered in the system */
  ListPolicies(request: ListPoliciesRequest): Promise<ListPoliciesResponse>;
  /** DeletePolicy removes a Policy and all relationships and objects registered within it. */
  DeletePolicy(request: DeletePolicyRequest): Promise<DeletePolicyResponse>;
  /**
   * SetRelationship creates or updates a Relationship within a Policy
   * A Relationship is a statement which ties together an object and a subject with a "relation",
   * which means the set of high level rules defined in the Policy will apply to these entities.
   */
  SetRelationship(request: SetRelationshipRequest): Promise<SetRelationshipResponse>;
  /**
   * DelereRelationship removes a Relationship from a Policy.
   * If the Relationship was not found in a Policy, this Cmd is a no-op.
   */
  DeleteRelationship(request: DeleteRelationshipRequest): Promise<DeleteRelationshipResponse>;
  /**
   * RegisterObject creates a special kind of Relationship within a Policy which ties
   * the msg's Actor as the owner of the msg's Object.
   * The Owner has complete control over the set of subjects that are related to their Object,
   * giving them autonomy to share the object and revoke acces to the object,
   * much like owners in a Discretionary Access Control model.
   *
   * Attempting to register a previously registered Object - whether active or archived -
   * is an error, Object IDs are therefore assumed to be unique within a Policy.
   */
  RegisterObject(request: RegisterObjectRequest): Promise<RegisterObjectResponse>;
  /**
   * ArchiveObject sets an Object's state as "archived"
   *
   * Archiving an object removes all relationships and effectively disables it.
   * No relationships can be created for it and no checks can be executed against it.
   * Note that the original owner record is preserved for security reasons.
   *
   * Attempting to archive an already archived object is a noop.
   * Archiving an object that isn't registered is an error
   * Only the owner can archive an object
   *
   * Note: ownership records aren't removed since doing so could lead to an ownership hijack attack.
   * In order to pass ownership to another owner, use the TransferObject method.
   *
   * Hijack attacks look like the following:
   * Suppose Bob owns object Foo, which is shared with Bob but not Eve.
   * Eve wants to access Foo but was not given permission to it.
   * Eve could "hijack" Bob's object by waiting for Bob to delete its ownership record for Foo,
   * then submitting a RegisterObject Cmd, effectively becoming Foo's new owner.
   * If Charlie has a copy of the object, Eve could convince Charlie to share his copy, granting Eve access to Foo.
   * The previous scenario where an unauthorized user is able to claim ownership to data previously unaccessible to them
   * is an "ownership hijack".
   */
  ArchiveObject(request: ArchiveObjectRequest): Promise<ArchiveObjectResponse>;
  /**
   * TransferObject updates an Object's Owner to some other actor in the system, after which the original owner
   * loses autonomy over the object and cannot create or modify relationships.
   *
   * Transfering object cannot be reversed, unless another Transfer is initiated by the new owner.
   *
   * Transfering an archived or unregistered object is an error.
   * Only the owner can transfer an object.
   */
  TransferObject(request: TransferObjectRequest): Promise<TransferObjectResponse>;
  /**
   * UnarchiveObject returns a previously archived object to active status,
   * such that the owner is able to create relationships and share that object again.
   *
   * Only the original owner of the object can unarchive it, returns an authorization error otherwise.
   * Attempting to unarchive an active or unregistered object is an error.
   */
  UnarchiveObject(request: UnarchiveObjectRequest): Promise<UnarchiveObjectResponse>;
  /**
   * AmendRegistration transfer an object's ownership between two users
   * This operation can only be executed by the root principal.
   *
   * Amending the registration of an archived or unregistered object is an error.
   */
  AmendRegistration(request: AmendRegistrationRequest): Promise<AmendRegistrationResponse>;
  /**
   * RevealRegistration registers an object at a specific time stamp.
   *
   * This command can be paired with an external commitment protocol to reserve an object without exposing it.
   */
  RevealRegistration(request: RevealRegistrationRequest): Promise<RevealRegistrationResponse>;
  /**
   * EvaluateTheorem executes the given theorem against a stored policy.
   *
   * Returns an error if the policy does not exist.
   */
  EvaluateTheorem(request: EvaluateTheoremRequest): Promise<EvaluateTheoremResponse>;
  /** GetObjectRegistration returns the registration status of an Object */
  GetObjectRegistration(request: GetObjectRegistrationRequest): Promise<GetObjectRegistrationResponse>;
  /** FilterRelationships returns filtered set of Relationships in a Policy. */
  FilterRelationships(request: FilterRelationshipsRequest): Promise<FilterRelationshipsResponse>;
  /**
   * ValidatePolicy verifies whether a policy payload is valid and would be accepted
   * by the engine, without creating it.
   *
   * Returns ok or validation errors found within the policy construction
   */
  ValidatePolicy(request: ValidatePolicyRequest): Promise<ValidatePolicyResponse>;
  /**
   * SetParams tunes the parameters of the ACP Engine.
   * This operation can only be done by the root principal
   */
  SetParams(request: SetParamsRequest): Promise<SetParamsResponse>;
  /** GetParams returns the current params set in the ACP Engine. */
  GetParams(request: GetParamsRequest): Promise<GetParamsResponse>;
  /**
   * VerifyAccessRequest evaluates an AccessRequest
   * Returns true if the authenticated actor is allowed to perform the operations they are requesting.
   * FIXME: there is no need to bind the authenticated principal to the AccessRequest,
   * the verification is often done by someone else
   */
  VerifyAccessRequest(request: VerifyAccessRequestRequest): Promise<VerifyAccessRequestResponse>;
}
