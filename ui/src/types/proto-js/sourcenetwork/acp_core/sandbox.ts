// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: sourcenetwork/acp_core/sandbox.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { LocatedMessage } from "./parser_message";
import { Policy } from "./policy";
import { Relationship } from "./relationship";
import { PolicyTheorem } from "./theorem";

export const protobufPackage = "sourcenetwork.acp_core";

/** SandboxRecord represents an instance of a sandbox */
export interface SandboxRecord {
  /** Handle is an opaque identifier to a sandbox */
  handle: number;
  /** name is a user given designation to a sandbox */
  name: string;
  description: string;
  data:
    | SandboxData
    | undefined;
  /** scratchpad acts as temporary storage for modifications in the sandbox data */
  scratchpad: SandboxData | undefined;
  ctx: SandboxCtx | undefined;
  initialized: boolean;
}

/** SandboxData encapsulates all the data necessary to create a Sandbox */
export interface SandboxData {
  /** policy_definition contains a yaml serialized policy which will be loaded in the sandbox */
  policyDefinition: string;
  /**
   * relationships is a set of line separated relationships, as defined in the PolicyTheoremDSL
   * For an introduction to the language, check acp_core docs
   */
  relationships: string;
  /**
   * policy_theorem is a PolicyTheoremDSL document representing a PolicyTheorem.
   * For an introduction to the language, check acp_core docs
   */
  policyTheorem: string;
}

/**
 * SandboxCtx encapsulated all context data
 * to execute an isolated theorem execution simulation
 */
export interface SandboxCtx {
  /** policy contains the parsed policy as defined in SandboxData */
  policy:
    | Policy
    | undefined;
  /** relationships contains the parsed relationships as defined in SandboxData */
  relationships: Relationship[];
  /** policy_theorem contains the parsed policy_theorem as defined in SandboxData */
  policyTheorem: PolicyTheorem | undefined;
}

export interface SandboxDataErrors {
  /**
   * policy_errors contains all errors encountered while
   * processing the given policy
   */
  policyErrors: LocatedMessage[];
  /**
   * policy_errors contains all errors encountered while
   * processing the relationship set
   */
  relationshipsErrors: LocatedMessage[];
  /**
   * policy_errors contains all errors encountered while
   * parsing the theorems
   */
  theoremsErrors: LocatedMessage[];
}

function createBaseSandboxRecord(): SandboxRecord {
  return {
    handle: 0,
    name: "",
    description: "",
    data: undefined,
    scratchpad: undefined,
    ctx: undefined,
    initialized: false,
  };
}

export const SandboxRecord: MessageFns<SandboxRecord> = {
  encode(message: SandboxRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.handle !== 0) {
      writer.uint32(8).uint64(message.handle);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.data !== undefined) {
      SandboxData.encode(message.data, writer.uint32(34).fork()).join();
    }
    if (message.scratchpad !== undefined) {
      SandboxData.encode(message.scratchpad, writer.uint32(42).fork()).join();
    }
    if (message.ctx !== undefined) {
      SandboxCtx.encode(message.ctx, writer.uint32(50).fork()).join();
    }
    if (message.initialized !== false) {
      writer.uint32(56).bool(message.initialized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SandboxRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSandboxRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.handle = longToNumber(reader.uint64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = SandboxData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scratchpad = SandboxData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ctx = SandboxCtx.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.initialized = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SandboxRecord {
    return {
      handle: isSet(object.handle) ? globalThis.Number(object.handle) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      data: isSet(object.data) ? SandboxData.fromJSON(object.data) : undefined,
      scratchpad: isSet(object.scratchpad) ? SandboxData.fromJSON(object.scratchpad) : undefined,
      ctx: isSet(object.ctx) ? SandboxCtx.fromJSON(object.ctx) : undefined,
      initialized: isSet(object.initialized) ? globalThis.Boolean(object.initialized) : false,
    };
  },

  toJSON(message: SandboxRecord): unknown {
    const obj: any = {};
    if (message.handle !== 0) {
      obj.handle = Math.round(message.handle);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.data !== undefined) {
      obj.data = SandboxData.toJSON(message.data);
    }
    if (message.scratchpad !== undefined) {
      obj.scratchpad = SandboxData.toJSON(message.scratchpad);
    }
    if (message.ctx !== undefined) {
      obj.ctx = SandboxCtx.toJSON(message.ctx);
    }
    if (message.initialized !== false) {
      obj.initialized = message.initialized;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SandboxRecord>, I>>(base?: I): SandboxRecord {
    return SandboxRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SandboxRecord>, I>>(object: I): SandboxRecord {
    const message = createBaseSandboxRecord();
    message.handle = object.handle ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.data = (object.data !== undefined && object.data !== null)
      ? SandboxData.fromPartial(object.data)
      : undefined;
    message.scratchpad = (object.scratchpad !== undefined && object.scratchpad !== null)
      ? SandboxData.fromPartial(object.scratchpad)
      : undefined;
    message.ctx = (object.ctx !== undefined && object.ctx !== null) ? SandboxCtx.fromPartial(object.ctx) : undefined;
    message.initialized = object.initialized ?? false;
    return message;
  },
};

function createBaseSandboxData(): SandboxData {
  return { policyDefinition: "", relationships: "", policyTheorem: "" };
}

export const SandboxData: MessageFns<SandboxData> = {
  encode(message: SandboxData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policyDefinition !== "") {
      writer.uint32(10).string(message.policyDefinition);
    }
    if (message.relationships !== "") {
      writer.uint32(18).string(message.relationships);
    }
    if (message.policyTheorem !== "") {
      writer.uint32(26).string(message.policyTheorem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SandboxData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSandboxData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyDefinition = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationships = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyTheorem = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SandboxData {
    return {
      policyDefinition: isSet(object.policyDefinition) ? globalThis.String(object.policyDefinition) : "",
      relationships: isSet(object.relationships) ? globalThis.String(object.relationships) : "",
      policyTheorem: isSet(object.policyTheorem) ? globalThis.String(object.policyTheorem) : "",
    };
  },

  toJSON(message: SandboxData): unknown {
    const obj: any = {};
    if (message.policyDefinition !== "") {
      obj.policyDefinition = message.policyDefinition;
    }
    if (message.relationships !== "") {
      obj.relationships = message.relationships;
    }
    if (message.policyTheorem !== "") {
      obj.policyTheorem = message.policyTheorem;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SandboxData>, I>>(base?: I): SandboxData {
    return SandboxData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SandboxData>, I>>(object: I): SandboxData {
    const message = createBaseSandboxData();
    message.policyDefinition = object.policyDefinition ?? "";
    message.relationships = object.relationships ?? "";
    message.policyTheorem = object.policyTheorem ?? "";
    return message;
  },
};

function createBaseSandboxCtx(): SandboxCtx {
  return { policy: undefined, relationships: [], policyTheorem: undefined };
}

export const SandboxCtx: MessageFns<SandboxCtx> = {
  encode(message: SandboxCtx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    for (const v of message.relationships) {
      Relationship.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.policyTheorem !== undefined) {
      PolicyTheorem.encode(message.policyTheorem, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SandboxCtx {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSandboxCtx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationships.push(Relationship.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyTheorem = PolicyTheorem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SandboxCtx {
    return {
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      relationships: globalThis.Array.isArray(object?.relationships)
        ? object.relationships.map((e: any) => Relationship.fromJSON(e))
        : [],
      policyTheorem: isSet(object.policyTheorem) ? PolicyTheorem.fromJSON(object.policyTheorem) : undefined,
    };
  },

  toJSON(message: SandboxCtx): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.relationships?.length) {
      obj.relationships = message.relationships.map((e) => Relationship.toJSON(e));
    }
    if (message.policyTheorem !== undefined) {
      obj.policyTheorem = PolicyTheorem.toJSON(message.policyTheorem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SandboxCtx>, I>>(base?: I): SandboxCtx {
    return SandboxCtx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SandboxCtx>, I>>(object: I): SandboxCtx {
    const message = createBaseSandboxCtx();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.relationships = object.relationships?.map((e) => Relationship.fromPartial(e)) || [];
    message.policyTheorem = (object.policyTheorem !== undefined && object.policyTheorem !== null)
      ? PolicyTheorem.fromPartial(object.policyTheorem)
      : undefined;
    return message;
  },
};

function createBaseSandboxDataErrors(): SandboxDataErrors {
  return { policyErrors: [], relationshipsErrors: [], theoremsErrors: [] };
}

export const SandboxDataErrors: MessageFns<SandboxDataErrors> = {
  encode(message: SandboxDataErrors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policyErrors) {
      LocatedMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.relationshipsErrors) {
      LocatedMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.theoremsErrors) {
      LocatedMessage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SandboxDataErrors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSandboxDataErrors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyErrors.push(LocatedMessage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationshipsErrors.push(LocatedMessage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.theoremsErrors.push(LocatedMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SandboxDataErrors {
    return {
      policyErrors: globalThis.Array.isArray(object?.policyErrors)
        ? object.policyErrors.map((e: any) => LocatedMessage.fromJSON(e))
        : [],
      relationshipsErrors: globalThis.Array.isArray(object?.relationshipsErrors)
        ? object.relationshipsErrors.map((e: any) => LocatedMessage.fromJSON(e))
        : [],
      theoremsErrors: globalThis.Array.isArray(object?.theoremsErrors)
        ? object.theoremsErrors.map((e: any) => LocatedMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SandboxDataErrors): unknown {
    const obj: any = {};
    if (message.policyErrors?.length) {
      obj.policyErrors = message.policyErrors.map((e) => LocatedMessage.toJSON(e));
    }
    if (message.relationshipsErrors?.length) {
      obj.relationshipsErrors = message.relationshipsErrors.map((e) => LocatedMessage.toJSON(e));
    }
    if (message.theoremsErrors?.length) {
      obj.theoremsErrors = message.theoremsErrors.map((e) => LocatedMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SandboxDataErrors>, I>>(base?: I): SandboxDataErrors {
    return SandboxDataErrors.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SandboxDataErrors>, I>>(object: I): SandboxDataErrors {
    const message = createBaseSandboxDataErrors();
    message.policyErrors = object.policyErrors?.map((e) => LocatedMessage.fromPartial(e)) || [];
    message.relationshipsErrors = object.relationshipsErrors?.map((e) => LocatedMessage.fromPartial(e)) || [];
    message.theoremsErrors = object.theoremsErrors?.map((e) => LocatedMessage.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
