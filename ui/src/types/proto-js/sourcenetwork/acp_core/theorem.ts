// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: sourcenetwork/acp_core/theorem.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Operation } from "./access_decision";
import { BufferInterval } from "./buffer_position";
import { Actor, Object } from "./relationship";

export const protobufPackage = "sourcenetwork.acp_core";

/** ResultStatus models the possible results from executing a Theorem */
export enum ResultStatus {
  Reject = 0,
  Accept = 1,
  Error = 2,
  UNRECOGNIZED = -1,
}

export function resultStatusFromJSON(object: any): ResultStatus {
  switch (object) {
    case 0:
    case "Reject":
      return ResultStatus.Reject;
    case 1:
    case "Accept":
      return ResultStatus.Accept;
    case 2:
    case "Error":
      return ResultStatus.Error;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultStatus.UNRECOGNIZED;
  }
}

export function resultStatusToJSON(object: ResultStatus): string {
  switch (object) {
    case ResultStatus.Reject:
      return "Reject";
    case ResultStatus.Accept:
      return "Accept";
    case ResultStatus.Error:
      return "Error";
    case ResultStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AuthorizationTheorem states that the given AccessRequest request is valid (or not) in the context of a certain Policy */
export interface AuthorizationTheorem {
  operation: Operation | undefined;
  actor: Actor | undefined;
  assertTrue: boolean;
}

export interface ReachabilityTheorem {
  actor: Actor | undefined;
  operation: string;
  object: Object | undefined;
  assertTrue: boolean;
}

/**
 * DelegationTheorem models a statement declaring that actor can create and delete relationships
 * with `relation` for the given `object`
 */
export interface DelegationTheorem {
  actor: Actor | undefined;
  operation: Operation | undefined;
  assertTrue: boolean;
}

/** PolicyTheorem models a set of theorems about a Policy */
export interface PolicyTheorem {
  authorizationTheorems: AuthorizationTheorem[];
  delegationTheorems: DelegationTheorem[];
  reachabilityTheorems: ReachabilityTheorem[];
}

/** Result models the result of evaluating a theorem */
export interface Result {
  /** status indicates whether the theorem was accepted, rejected or an error happened */
  status: ResultStatus;
  /** Message explains the result */
  message: string;
}

export interface AuthorizationTheoremResult {
  theorem: AuthorizationTheorem | undefined;
  result: Result | undefined;
}

export interface DelegationTheoremResult {
  theorem: DelegationTheorem | undefined;
  result: Result | undefined;
}

export interface ReachabilityTheoremResult {
  theorem: ReachabilityTheorem | undefined;
  result: Result | undefined;
}

export interface AnnotatedAuthorizationTheoremResult {
  result: AuthorizationTheoremResult | undefined;
  interval: BufferInterval | undefined;
}

export interface AnnotatedDelegationTheoremResult {
  result: DelegationTheoremResult | undefined;
  interval: BufferInterval | undefined;
}

export interface AnnotatedReachabilityTheoremResult {
  result: ReachabilityTheoremResult | undefined;
  interval: BufferInterval | undefined;
}

export interface PolicyTheoremResult {
  theorem: PolicyTheorem | undefined;
  authorizationTheoremsResult: AuthorizationTheoremResult[];
  delegationTheoremsResult: DelegationTheoremResult[];
  reachabilityTheoremsResult: ReachabilityTheoremResult[];
}

export interface AnnotatedPolicyTheoremResult {
  theorem: PolicyTheorem | undefined;
  authorizationTheoremsResult: AnnotatedAuthorizationTheoremResult[];
  delegationTheoremsResult: AnnotatedDelegationTheoremResult[];
  reachabilityTheoremsResult: AnnotatedReachabilityTheoremResult[];
}

function createBaseAuthorizationTheorem(): AuthorizationTheorem {
  return { operation: undefined, actor: undefined, assertTrue: false };
}

export const AuthorizationTheorem: MessageFns<AuthorizationTheorem> = {
  encode(message: AuthorizationTheorem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(10).fork()).join();
    }
    if (message.actor !== undefined) {
      Actor.encode(message.actor, writer.uint32(18).fork()).join();
    }
    if (message.assertTrue !== false) {
      writer.uint32(24).bool(message.assertTrue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationTheorem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationTheorem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actor = Actor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.assertTrue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationTheorem {
    return {
      operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined,
      actor: isSet(object.actor) ? Actor.fromJSON(object.actor) : undefined,
      assertTrue: isSet(object.assertTrue) ? globalThis.Boolean(object.assertTrue) : false,
    };
  },

  toJSON(message: AuthorizationTheorem): unknown {
    const obj: any = {};
    if (message.operation !== undefined) {
      obj.operation = Operation.toJSON(message.operation);
    }
    if (message.actor !== undefined) {
      obj.actor = Actor.toJSON(message.actor);
    }
    if (message.assertTrue !== false) {
      obj.assertTrue = message.assertTrue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationTheorem>, I>>(base?: I): AuthorizationTheorem {
    return AuthorizationTheorem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationTheorem>, I>>(object: I): AuthorizationTheorem {
    const message = createBaseAuthorizationTheorem();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    message.actor = (object.actor !== undefined && object.actor !== null) ? Actor.fromPartial(object.actor) : undefined;
    message.assertTrue = object.assertTrue ?? false;
    return message;
  },
};

function createBaseReachabilityTheorem(): ReachabilityTheorem {
  return { actor: undefined, operation: "", object: undefined, assertTrue: false };
}

export const ReachabilityTheorem: MessageFns<ReachabilityTheorem> = {
  encode(message: ReachabilityTheorem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actor !== undefined) {
      Actor.encode(message.actor, writer.uint32(10).fork()).join();
    }
    if (message.operation !== "") {
      writer.uint32(18).string(message.operation);
    }
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(26).fork()).join();
    }
    if (message.assertTrue !== false) {
      writer.uint32(32).bool(message.assertTrue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReachabilityTheorem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReachabilityTheorem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actor = Actor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.assertTrue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReachabilityTheorem {
    return {
      actor: isSet(object.actor) ? Actor.fromJSON(object.actor) : undefined,
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
      assertTrue: isSet(object.assertTrue) ? globalThis.Boolean(object.assertTrue) : false,
    };
  },

  toJSON(message: ReachabilityTheorem): unknown {
    const obj: any = {};
    if (message.actor !== undefined) {
      obj.actor = Actor.toJSON(message.actor);
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    if (message.assertTrue !== false) {
      obj.assertTrue = message.assertTrue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReachabilityTheorem>, I>>(base?: I): ReachabilityTheorem {
    return ReachabilityTheorem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReachabilityTheorem>, I>>(object: I): ReachabilityTheorem {
    const message = createBaseReachabilityTheorem();
    message.actor = (object.actor !== undefined && object.actor !== null) ? Actor.fromPartial(object.actor) : undefined;
    message.operation = object.operation ?? "";
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    message.assertTrue = object.assertTrue ?? false;
    return message;
  },
};

function createBaseDelegationTheorem(): DelegationTheorem {
  return { actor: undefined, operation: undefined, assertTrue: false };
}

export const DelegationTheorem: MessageFns<DelegationTheorem> = {
  encode(message: DelegationTheorem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actor !== undefined) {
      Actor.encode(message.actor, writer.uint32(10).fork()).join();
    }
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(18).fork()).join();
    }
    if (message.assertTrue !== false) {
      writer.uint32(24).bool(message.assertTrue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegationTheorem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegationTheorem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actor = Actor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.assertTrue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegationTheorem {
    return {
      actor: isSet(object.actor) ? Actor.fromJSON(object.actor) : undefined,
      operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined,
      assertTrue: isSet(object.assertTrue) ? globalThis.Boolean(object.assertTrue) : false,
    };
  },

  toJSON(message: DelegationTheorem): unknown {
    const obj: any = {};
    if (message.actor !== undefined) {
      obj.actor = Actor.toJSON(message.actor);
    }
    if (message.operation !== undefined) {
      obj.operation = Operation.toJSON(message.operation);
    }
    if (message.assertTrue !== false) {
      obj.assertTrue = message.assertTrue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DelegationTheorem>, I>>(base?: I): DelegationTheorem {
    return DelegationTheorem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DelegationTheorem>, I>>(object: I): DelegationTheorem {
    const message = createBaseDelegationTheorem();
    message.actor = (object.actor !== undefined && object.actor !== null) ? Actor.fromPartial(object.actor) : undefined;
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    message.assertTrue = object.assertTrue ?? false;
    return message;
  },
};

function createBasePolicyTheorem(): PolicyTheorem {
  return { authorizationTheorems: [], delegationTheorems: [], reachabilityTheorems: [] };
}

export const PolicyTheorem: MessageFns<PolicyTheorem> = {
  encode(message: PolicyTheorem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.authorizationTheorems) {
      AuthorizationTheorem.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.delegationTheorems) {
      DelegationTheorem.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.reachabilityTheorems) {
      ReachabilityTheorem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTheorem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTheorem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authorizationTheorems.push(AuthorizationTheorem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.delegationTheorems.push(DelegationTheorem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reachabilityTheorems.push(ReachabilityTheorem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTheorem {
    return {
      authorizationTheorems: globalThis.Array.isArray(object?.authorizationTheorems)
        ? object.authorizationTheorems.map((e: any) => AuthorizationTheorem.fromJSON(e))
        : [],
      delegationTheorems: globalThis.Array.isArray(object?.delegationTheorems)
        ? object.delegationTheorems.map((e: any) => DelegationTheorem.fromJSON(e))
        : [],
      reachabilityTheorems: globalThis.Array.isArray(object?.reachabilityTheorems)
        ? object.reachabilityTheorems.map((e: any) => ReachabilityTheorem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolicyTheorem): unknown {
    const obj: any = {};
    if (message.authorizationTheorems?.length) {
      obj.authorizationTheorems = message.authorizationTheorems.map((e) => AuthorizationTheorem.toJSON(e));
    }
    if (message.delegationTheorems?.length) {
      obj.delegationTheorems = message.delegationTheorems.map((e) => DelegationTheorem.toJSON(e));
    }
    if (message.reachabilityTheorems?.length) {
      obj.reachabilityTheorems = message.reachabilityTheorems.map((e) => ReachabilityTheorem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PolicyTheorem>, I>>(base?: I): PolicyTheorem {
    return PolicyTheorem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PolicyTheorem>, I>>(object: I): PolicyTheorem {
    const message = createBasePolicyTheorem();
    message.authorizationTheorems = object.authorizationTheorems?.map((e) => AuthorizationTheorem.fromPartial(e)) || [];
    message.delegationTheorems = object.delegationTheorems?.map((e) => DelegationTheorem.fromPartial(e)) || [];
    message.reachabilityTheorems = object.reachabilityTheorems?.map((e) => ReachabilityTheorem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResult(): Result {
  return { status: 0, message: "" };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      status: isSet(object.status) ? resultStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = resultStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAuthorizationTheoremResult(): AuthorizationTheoremResult {
  return { theorem: undefined, result: undefined };
}

export const AuthorizationTheoremResult: MessageFns<AuthorizationTheoremResult> = {
  encode(message: AuthorizationTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.theorem !== undefined) {
      AuthorizationTheorem.encode(message.theorem, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.theorem = AuthorizationTheorem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationTheoremResult {
    return {
      theorem: isSet(object.theorem) ? AuthorizationTheorem.fromJSON(object.theorem) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: AuthorizationTheoremResult): unknown {
    const obj: any = {};
    if (message.theorem !== undefined) {
      obj.theorem = AuthorizationTheorem.toJSON(message.theorem);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthorizationTheoremResult>, I>>(base?: I): AuthorizationTheoremResult {
    return AuthorizationTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthorizationTheoremResult>, I>>(object: I): AuthorizationTheoremResult {
    const message = createBaseAuthorizationTheoremResult();
    message.theorem = (object.theorem !== undefined && object.theorem !== null)
      ? AuthorizationTheorem.fromPartial(object.theorem)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseDelegationTheoremResult(): DelegationTheoremResult {
  return { theorem: undefined, result: undefined };
}

export const DelegationTheoremResult: MessageFns<DelegationTheoremResult> = {
  encode(message: DelegationTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.theorem !== undefined) {
      DelegationTheorem.encode(message.theorem, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegationTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegationTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.theorem = DelegationTheorem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegationTheoremResult {
    return {
      theorem: isSet(object.theorem) ? DelegationTheorem.fromJSON(object.theorem) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: DelegationTheoremResult): unknown {
    const obj: any = {};
    if (message.theorem !== undefined) {
      obj.theorem = DelegationTheorem.toJSON(message.theorem);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DelegationTheoremResult>, I>>(base?: I): DelegationTheoremResult {
    return DelegationTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DelegationTheoremResult>, I>>(object: I): DelegationTheoremResult {
    const message = createBaseDelegationTheoremResult();
    message.theorem = (object.theorem !== undefined && object.theorem !== null)
      ? DelegationTheorem.fromPartial(object.theorem)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseReachabilityTheoremResult(): ReachabilityTheoremResult {
  return { theorem: undefined, result: undefined };
}

export const ReachabilityTheoremResult: MessageFns<ReachabilityTheoremResult> = {
  encode(message: ReachabilityTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.theorem !== undefined) {
      ReachabilityTheorem.encode(message.theorem, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReachabilityTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReachabilityTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.theorem = ReachabilityTheorem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReachabilityTheoremResult {
    return {
      theorem: isSet(object.theorem) ? ReachabilityTheorem.fromJSON(object.theorem) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: ReachabilityTheoremResult): unknown {
    const obj: any = {};
    if (message.theorem !== undefined) {
      obj.theorem = ReachabilityTheorem.toJSON(message.theorem);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReachabilityTheoremResult>, I>>(base?: I): ReachabilityTheoremResult {
    return ReachabilityTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReachabilityTheoremResult>, I>>(object: I): ReachabilityTheoremResult {
    const message = createBaseReachabilityTheoremResult();
    message.theorem = (object.theorem !== undefined && object.theorem !== null)
      ? ReachabilityTheorem.fromPartial(object.theorem)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseAnnotatedAuthorizationTheoremResult(): AnnotatedAuthorizationTheoremResult {
  return { result: undefined, interval: undefined };
}

export const AnnotatedAuthorizationTheoremResult: MessageFns<AnnotatedAuthorizationTheoremResult> = {
  encode(message: AnnotatedAuthorizationTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      AuthorizationTheoremResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.interval !== undefined) {
      BufferInterval.encode(message.interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedAuthorizationTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedAuthorizationTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = AuthorizationTheoremResult.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = BufferInterval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedAuthorizationTheoremResult {
    return {
      result: isSet(object.result) ? AuthorizationTheoremResult.fromJSON(object.result) : undefined,
      interval: isSet(object.interval) ? BufferInterval.fromJSON(object.interval) : undefined,
    };
  },

  toJSON(message: AnnotatedAuthorizationTheoremResult): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = AuthorizationTheoremResult.toJSON(message.result);
    }
    if (message.interval !== undefined) {
      obj.interval = BufferInterval.toJSON(message.interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotatedAuthorizationTheoremResult>, I>>(
    base?: I,
  ): AnnotatedAuthorizationTheoremResult {
    return AnnotatedAuthorizationTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotatedAuthorizationTheoremResult>, I>>(
    object: I,
  ): AnnotatedAuthorizationTheoremResult {
    const message = createBaseAnnotatedAuthorizationTheoremResult();
    message.result = (object.result !== undefined && object.result !== null)
      ? AuthorizationTheoremResult.fromPartial(object.result)
      : undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? BufferInterval.fromPartial(object.interval)
      : undefined;
    return message;
  },
};

function createBaseAnnotatedDelegationTheoremResult(): AnnotatedDelegationTheoremResult {
  return { result: undefined, interval: undefined };
}

export const AnnotatedDelegationTheoremResult: MessageFns<AnnotatedDelegationTheoremResult> = {
  encode(message: AnnotatedDelegationTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      DelegationTheoremResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.interval !== undefined) {
      BufferInterval.encode(message.interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedDelegationTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedDelegationTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = DelegationTheoremResult.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = BufferInterval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedDelegationTheoremResult {
    return {
      result: isSet(object.result) ? DelegationTheoremResult.fromJSON(object.result) : undefined,
      interval: isSet(object.interval) ? BufferInterval.fromJSON(object.interval) : undefined,
    };
  },

  toJSON(message: AnnotatedDelegationTheoremResult): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = DelegationTheoremResult.toJSON(message.result);
    }
    if (message.interval !== undefined) {
      obj.interval = BufferInterval.toJSON(message.interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotatedDelegationTheoremResult>, I>>(
    base?: I,
  ): AnnotatedDelegationTheoremResult {
    return AnnotatedDelegationTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotatedDelegationTheoremResult>, I>>(
    object: I,
  ): AnnotatedDelegationTheoremResult {
    const message = createBaseAnnotatedDelegationTheoremResult();
    message.result = (object.result !== undefined && object.result !== null)
      ? DelegationTheoremResult.fromPartial(object.result)
      : undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? BufferInterval.fromPartial(object.interval)
      : undefined;
    return message;
  },
};

function createBaseAnnotatedReachabilityTheoremResult(): AnnotatedReachabilityTheoremResult {
  return { result: undefined, interval: undefined };
}

export const AnnotatedReachabilityTheoremResult: MessageFns<AnnotatedReachabilityTheoremResult> = {
  encode(message: AnnotatedReachabilityTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      ReachabilityTheoremResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.interval !== undefined) {
      BufferInterval.encode(message.interval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedReachabilityTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedReachabilityTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = ReachabilityTheoremResult.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = BufferInterval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedReachabilityTheoremResult {
    return {
      result: isSet(object.result) ? ReachabilityTheoremResult.fromJSON(object.result) : undefined,
      interval: isSet(object.interval) ? BufferInterval.fromJSON(object.interval) : undefined,
    };
  },

  toJSON(message: AnnotatedReachabilityTheoremResult): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = ReachabilityTheoremResult.toJSON(message.result);
    }
    if (message.interval !== undefined) {
      obj.interval = BufferInterval.toJSON(message.interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotatedReachabilityTheoremResult>, I>>(
    base?: I,
  ): AnnotatedReachabilityTheoremResult {
    return AnnotatedReachabilityTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotatedReachabilityTheoremResult>, I>>(
    object: I,
  ): AnnotatedReachabilityTheoremResult {
    const message = createBaseAnnotatedReachabilityTheoremResult();
    message.result = (object.result !== undefined && object.result !== null)
      ? ReachabilityTheoremResult.fromPartial(object.result)
      : undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? BufferInterval.fromPartial(object.interval)
      : undefined;
    return message;
  },
};

function createBasePolicyTheoremResult(): PolicyTheoremResult {
  return {
    theorem: undefined,
    authorizationTheoremsResult: [],
    delegationTheoremsResult: [],
    reachabilityTheoremsResult: [],
  };
}

export const PolicyTheoremResult: MessageFns<PolicyTheoremResult> = {
  encode(message: PolicyTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.theorem !== undefined) {
      PolicyTheorem.encode(message.theorem, writer.uint32(10).fork()).join();
    }
    for (const v of message.authorizationTheoremsResult) {
      AuthorizationTheoremResult.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.delegationTheoremsResult) {
      DelegationTheoremResult.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.reachabilityTheoremsResult) {
      ReachabilityTheoremResult.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.theorem = PolicyTheorem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authorizationTheoremsResult.push(AuthorizationTheoremResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.delegationTheoremsResult.push(DelegationTheoremResult.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reachabilityTheoremsResult.push(ReachabilityTheoremResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyTheoremResult {
    return {
      theorem: isSet(object.theorem) ? PolicyTheorem.fromJSON(object.theorem) : undefined,
      authorizationTheoremsResult: globalThis.Array.isArray(object?.authorizationTheoremsResult)
        ? object.authorizationTheoremsResult.map((e: any) => AuthorizationTheoremResult.fromJSON(e))
        : [],
      delegationTheoremsResult: globalThis.Array.isArray(object?.delegationTheoremsResult)
        ? object.delegationTheoremsResult.map((e: any) => DelegationTheoremResult.fromJSON(e))
        : [],
      reachabilityTheoremsResult: globalThis.Array.isArray(object?.reachabilityTheoremsResult)
        ? object.reachabilityTheoremsResult.map((e: any) => ReachabilityTheoremResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolicyTheoremResult): unknown {
    const obj: any = {};
    if (message.theorem !== undefined) {
      obj.theorem = PolicyTheorem.toJSON(message.theorem);
    }
    if (message.authorizationTheoremsResult?.length) {
      obj.authorizationTheoremsResult = message.authorizationTheoremsResult.map((e) =>
        AuthorizationTheoremResult.toJSON(e)
      );
    }
    if (message.delegationTheoremsResult?.length) {
      obj.delegationTheoremsResult = message.delegationTheoremsResult.map((e) => DelegationTheoremResult.toJSON(e));
    }
    if (message.reachabilityTheoremsResult?.length) {
      obj.reachabilityTheoremsResult = message.reachabilityTheoremsResult.map((e) =>
        ReachabilityTheoremResult.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PolicyTheoremResult>, I>>(base?: I): PolicyTheoremResult {
    return PolicyTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PolicyTheoremResult>, I>>(object: I): PolicyTheoremResult {
    const message = createBasePolicyTheoremResult();
    message.theorem = (object.theorem !== undefined && object.theorem !== null)
      ? PolicyTheorem.fromPartial(object.theorem)
      : undefined;
    message.authorizationTheoremsResult =
      object.authorizationTheoremsResult?.map((e) => AuthorizationTheoremResult.fromPartial(e)) || [];
    message.delegationTheoremsResult =
      object.delegationTheoremsResult?.map((e) => DelegationTheoremResult.fromPartial(e)) || [];
    message.reachabilityTheoremsResult =
      object.reachabilityTheoremsResult?.map((e) => ReachabilityTheoremResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnnotatedPolicyTheoremResult(): AnnotatedPolicyTheoremResult {
  return {
    theorem: undefined,
    authorizationTheoremsResult: [],
    delegationTheoremsResult: [],
    reachabilityTheoremsResult: [],
  };
}

export const AnnotatedPolicyTheoremResult: MessageFns<AnnotatedPolicyTheoremResult> = {
  encode(message: AnnotatedPolicyTheoremResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.theorem !== undefined) {
      PolicyTheorem.encode(message.theorem, writer.uint32(10).fork()).join();
    }
    for (const v of message.authorizationTheoremsResult) {
      AnnotatedAuthorizationTheoremResult.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.delegationTheoremsResult) {
      AnnotatedDelegationTheoremResult.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.reachabilityTheoremsResult) {
      AnnotatedReachabilityTheoremResult.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedPolicyTheoremResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedPolicyTheoremResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.theorem = PolicyTheorem.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authorizationTheoremsResult.push(AnnotatedAuthorizationTheoremResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.delegationTheoremsResult.push(AnnotatedDelegationTheoremResult.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reachabilityTheoremsResult.push(AnnotatedReachabilityTheoremResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedPolicyTheoremResult {
    return {
      theorem: isSet(object.theorem) ? PolicyTheorem.fromJSON(object.theorem) : undefined,
      authorizationTheoremsResult: globalThis.Array.isArray(object?.authorizationTheoremsResult)
        ? object.authorizationTheoremsResult.map((e: any) => AnnotatedAuthorizationTheoremResult.fromJSON(e))
        : [],
      delegationTheoremsResult: globalThis.Array.isArray(object?.delegationTheoremsResult)
        ? object.delegationTheoremsResult.map((e: any) => AnnotatedDelegationTheoremResult.fromJSON(e))
        : [],
      reachabilityTheoremsResult: globalThis.Array.isArray(object?.reachabilityTheoremsResult)
        ? object.reachabilityTheoremsResult.map((e: any) => AnnotatedReachabilityTheoremResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AnnotatedPolicyTheoremResult): unknown {
    const obj: any = {};
    if (message.theorem !== undefined) {
      obj.theorem = PolicyTheorem.toJSON(message.theorem);
    }
    if (message.authorizationTheoremsResult?.length) {
      obj.authorizationTheoremsResult = message.authorizationTheoremsResult.map((e) =>
        AnnotatedAuthorizationTheoremResult.toJSON(e)
      );
    }
    if (message.delegationTheoremsResult?.length) {
      obj.delegationTheoremsResult = message.delegationTheoremsResult.map((e) =>
        AnnotatedDelegationTheoremResult.toJSON(e)
      );
    }
    if (message.reachabilityTheoremsResult?.length) {
      obj.reachabilityTheoremsResult = message.reachabilityTheoremsResult.map((e) =>
        AnnotatedReachabilityTheoremResult.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotatedPolicyTheoremResult>, I>>(base?: I): AnnotatedPolicyTheoremResult {
    return AnnotatedPolicyTheoremResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotatedPolicyTheoremResult>, I>>(object: I): AnnotatedPolicyTheoremResult {
    const message = createBaseAnnotatedPolicyTheoremResult();
    message.theorem = (object.theorem !== undefined && object.theorem !== null)
      ? PolicyTheorem.fromPartial(object.theorem)
      : undefined;
    message.authorizationTheoremsResult =
      object.authorizationTheoremsResult?.map((e) => AnnotatedAuthorizationTheoremResult.fromPartial(e)) || [];
    message.delegationTheoremsResult =
      object.delegationTheoremsResult?.map((e) => AnnotatedDelegationTheoremResult.fromPartial(e)) || [];
    message.reachabilityTheoremsResult =
      object.reachabilityTheoremsResult?.map((e) => AnnotatedReachabilityTheoremResult.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
