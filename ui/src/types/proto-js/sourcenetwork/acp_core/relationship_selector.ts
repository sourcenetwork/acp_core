// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: sourcenetwork/acp_core/relationship_selector.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Object, Subject } from "./relationship";

export const protobufPackage = "sourcenetwork.acp_core";

/**
 * RelationshipSelector models a set of predicates which are used to filter through
 * Relationships in a Policy.
 */
export interface RelationshipSelector {
  objectSelector: ObjectSelector | undefined;
  relationSelector: RelationSelector | undefined;
  subjectSelector: SubjectSelector | undefined;
}

/** ObjectSelector models a filter for Relationship Objects */
export interface ObjectSelector {
  /** object specifies an object which the Relationship must contain */
  object?:
    | Object
    | undefined;
  /** wildcard matches any object */
  wildcard?: WildcardSelector | undefined;
  resourcePredicate?: string | undefined;
}

/** RelationsSelector models a filter for Relationship Relations */
export interface RelationSelector {
  /** relation specifies a relation name which must exactly match the Relationship's */
  relation?:
    | string
    | undefined;
  /** wildcard matches any relation */
  wildcard?: WildcardSelector | undefined;
}

/** SubjectSelector models a filter for Relationship Subjects */
export interface SubjectSelector {
  /** subject requires an exact match between the given subject and a Relationship's subject */
  subject?:
    | Subject
    | undefined;
  /** wildcard matches any subject in a Relationship */
  wildcard?: WildcardSelector | undefined;
}

/** WildcardSelector matches anything in a context */
export interface WildcardSelector {
}

function createBaseRelationshipSelector(): RelationshipSelector {
  return { objectSelector: undefined, relationSelector: undefined, subjectSelector: undefined };
}

export const RelationshipSelector: MessageFns<RelationshipSelector> = {
  encode(message: RelationshipSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.objectSelector !== undefined) {
      ObjectSelector.encode(message.objectSelector, writer.uint32(10).fork()).join();
    }
    if (message.relationSelector !== undefined) {
      RelationSelector.encode(message.relationSelector, writer.uint32(18).fork()).join();
    }
    if (message.subjectSelector !== undefined) {
      SubjectSelector.encode(message.subjectSelector, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelationshipSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelationshipSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.objectSelector = ObjectSelector.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.relationSelector = RelationSelector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subjectSelector = SubjectSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelationshipSelector {
    return {
      objectSelector: isSet(object.objectSelector) ? ObjectSelector.fromJSON(object.objectSelector) : undefined,
      relationSelector: isSet(object.relationSelector) ? RelationSelector.fromJSON(object.relationSelector) : undefined,
      subjectSelector: isSet(object.subjectSelector) ? SubjectSelector.fromJSON(object.subjectSelector) : undefined,
    };
  },

  toJSON(message: RelationshipSelector): unknown {
    const obj: any = {};
    if (message.objectSelector !== undefined) {
      obj.objectSelector = ObjectSelector.toJSON(message.objectSelector);
    }
    if (message.relationSelector !== undefined) {
      obj.relationSelector = RelationSelector.toJSON(message.relationSelector);
    }
    if (message.subjectSelector !== undefined) {
      obj.subjectSelector = SubjectSelector.toJSON(message.subjectSelector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RelationshipSelector>, I>>(base?: I): RelationshipSelector {
    return RelationshipSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RelationshipSelector>, I>>(object: I): RelationshipSelector {
    const message = createBaseRelationshipSelector();
    message.objectSelector = (object.objectSelector !== undefined && object.objectSelector !== null)
      ? ObjectSelector.fromPartial(object.objectSelector)
      : undefined;
    message.relationSelector = (object.relationSelector !== undefined && object.relationSelector !== null)
      ? RelationSelector.fromPartial(object.relationSelector)
      : undefined;
    message.subjectSelector = (object.subjectSelector !== undefined && object.subjectSelector !== null)
      ? SubjectSelector.fromPartial(object.subjectSelector)
      : undefined;
    return message;
  },
};

function createBaseObjectSelector(): ObjectSelector {
  return { object: undefined, wildcard: undefined, resourcePredicate: undefined };
}

export const ObjectSelector: MessageFns<ObjectSelector> = {
  encode(message: ObjectSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.object !== undefined) {
      Object.encode(message.object, writer.uint32(10).fork()).join();
    }
    if (message.wildcard !== undefined) {
      WildcardSelector.encode(message.wildcard, writer.uint32(18).fork()).join();
    }
    if (message.resourcePredicate !== undefined) {
      writer.uint32(26).string(message.resourcePredicate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.object = Object.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wildcard = WildcardSelector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourcePredicate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectSelector {
    return {
      object: isSet(object.object) ? Object.fromJSON(object.object) : undefined,
      wildcard: isSet(object.wildcard) ? WildcardSelector.fromJSON(object.wildcard) : undefined,
      resourcePredicate: isSet(object.resourcePredicate) ? globalThis.String(object.resourcePredicate) : undefined,
    };
  },

  toJSON(message: ObjectSelector): unknown {
    const obj: any = {};
    if (message.object !== undefined) {
      obj.object = Object.toJSON(message.object);
    }
    if (message.wildcard !== undefined) {
      obj.wildcard = WildcardSelector.toJSON(message.wildcard);
    }
    if (message.resourcePredicate !== undefined) {
      obj.resourcePredicate = message.resourcePredicate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ObjectSelector>, I>>(base?: I): ObjectSelector {
    return ObjectSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ObjectSelector>, I>>(object: I): ObjectSelector {
    const message = createBaseObjectSelector();
    message.object = (object.object !== undefined && object.object !== null)
      ? Object.fromPartial(object.object)
      : undefined;
    message.wildcard = (object.wildcard !== undefined && object.wildcard !== null)
      ? WildcardSelector.fromPartial(object.wildcard)
      : undefined;
    message.resourcePredicate = object.resourcePredicate ?? undefined;
    return message;
  },
};

function createBaseRelationSelector(): RelationSelector {
  return { relation: undefined, wildcard: undefined };
}

export const RelationSelector: MessageFns<RelationSelector> = {
  encode(message: RelationSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.relation !== undefined) {
      writer.uint32(10).string(message.relation);
    }
    if (message.wildcard !== undefined) {
      WildcardSelector.encode(message.wildcard, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelationSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelationSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wildcard = WildcardSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelationSelector {
    return {
      relation: isSet(object.relation) ? globalThis.String(object.relation) : undefined,
      wildcard: isSet(object.wildcard) ? WildcardSelector.fromJSON(object.wildcard) : undefined,
    };
  },

  toJSON(message: RelationSelector): unknown {
    const obj: any = {};
    if (message.relation !== undefined) {
      obj.relation = message.relation;
    }
    if (message.wildcard !== undefined) {
      obj.wildcard = WildcardSelector.toJSON(message.wildcard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RelationSelector>, I>>(base?: I): RelationSelector {
    return RelationSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RelationSelector>, I>>(object: I): RelationSelector {
    const message = createBaseRelationSelector();
    message.relation = object.relation ?? undefined;
    message.wildcard = (object.wildcard !== undefined && object.wildcard !== null)
      ? WildcardSelector.fromPartial(object.wildcard)
      : undefined;
    return message;
  },
};

function createBaseSubjectSelector(): SubjectSelector {
  return { subject: undefined, wildcard: undefined };
}

export const SubjectSelector: MessageFns<SubjectSelector> = {
  encode(message: SubjectSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      Subject.encode(message.subject, writer.uint32(10).fork()).join();
    }
    if (message.wildcard !== undefined) {
      WildcardSelector.encode(message.wildcard, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubjectSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject = Subject.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wildcard = WildcardSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectSelector {
    return {
      subject: isSet(object.subject) ? Subject.fromJSON(object.subject) : undefined,
      wildcard: isSet(object.wildcard) ? WildcardSelector.fromJSON(object.wildcard) : undefined,
    };
  },

  toJSON(message: SubjectSelector): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = Subject.toJSON(message.subject);
    }
    if (message.wildcard !== undefined) {
      obj.wildcard = WildcardSelector.toJSON(message.wildcard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubjectSelector>, I>>(base?: I): SubjectSelector {
    return SubjectSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubjectSelector>, I>>(object: I): SubjectSelector {
    const message = createBaseSubjectSelector();
    message.subject = (object.subject !== undefined && object.subject !== null)
      ? Subject.fromPartial(object.subject)
      : undefined;
    message.wildcard = (object.wildcard !== undefined && object.wildcard !== null)
      ? WildcardSelector.fromPartial(object.wildcard)
      : undefined;
    return message;
  },
};

function createBaseWildcardSelector(): WildcardSelector {
  return {};
}

export const WildcardSelector: MessageFns<WildcardSelector> = {
  encode(_: WildcardSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WildcardSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWildcardSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WildcardSelector {
    return {};
  },

  toJSON(_: WildcardSelector): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WildcardSelector>, I>>(base?: I): WildcardSelector {
    return WildcardSelector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WildcardSelector>, I>>(_: I): WildcardSelector {
    const message = createBaseWildcardSelector();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
